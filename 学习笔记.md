# Learn-Django-2.0
B站课程学习https://www.bilibili.com/video/BV1GW411Y7EU

https://space.bilibili.com/252028233/video

# 课程源码地址

https://github.com/HaddyYang/django2.0-course

# 目录

[TOC]

----------

# 课程基本信息

https://www.bilibili.com/video/BV1GW411Y7EU
**版本情况：**

# 环境配置

**官网文档：**
https://docs.djangoproject.com/zh-hans/2.1/
**下载Django：**

```
$ conda activate envs (envs) 
$ pip install Django==2.0
```

# 二、入门仪式：Hello World

## 创建项目命令：

```
$ django-admin startproject<项目名>
```

## Django项目基本结构

![](https://raw.githubusercontent.com/GittenHub/GittenPicRepo/master/Image.png)

## 响应请求

![](https://raw.githubusercontent.com/GittenHub/GittenPicRepo/master/Imag1e.png)

## 根目录下创建views.py

```python
#views.py  创建一个index方法
from django.http import HttpResponse

def index(request):
	return HttpResponse("Hello, world")
```

## 在urls.py中新建一个路由

```python
#urls.py 
from django.contrib import admin 
from django.urls import path 
from . import views 

urlpatterns = [     
    path('admin/', admin.site.urls),#后台管理网址     
    path('', views.index),   #设置一个空的路由，不设置就是ip后没有目录，需要创建一个方法 ]
```

## re_path与path的区别

是否使用正则表达式

## 启动本地服务

```
/mysite $ python manage.py runserver
```

## 迁移数据库

```
/mysite $ python manage.py migrate
```

数据库类型修改在settings.py中

## 默认后台管理

http://127.0.0.1:8000/admin

## 创建超级用户

```
$ python manage.py createsuperuser
```

账号：gitten
密码：123456

>命令行帮助：python manage.py help

# 三、基本响应结构

## 多种相似结构的页面处理方式

![](https://raw.githubusercontent.com/GittenHub/GittenPicRepo/master/Image2.png)
抽象处理为模型

## 创建一个应用

```
$ python manage.py startapp <应用名称>
```

编辑settings.py文件

```python
#settings.py
INSTALLED_APPS = [
    'django.contrib.admin',
  	...,
    'article'  
]
```

## 同步数据库

```
$ python manage.py makemigrations  #制造迁移
$ python manage.py migrate  #迁移
```

## 将app添加到网站的后台管理

编辑article这个app文件夹下的admin.py

## 将网站后台修改为中文

修改settings.py文件

```python
#settings.py
...
LANGUAGE_CODE = 'zh-Hans'
```


# 四、使用模版显示内容

## 查看文章页面

```python
# article/views.py
from django.shortcuts import render
from django.http import HttpResponse
from .models import Article  #引用创建的模型

# Create your views here.
def article_detail(request,article_id):
	return HttpResponse("文章id: %s" % article_id)
```

```python
# urls.py
from django.contrib import admin
from django.urls import path
from . import views
from article.views import article_detail  #引用article包中views的article_detail方法

urlpatterns = [
   ...
    path('article/<int:article_id>', article_detail, name="article_detail"), #本行中的<int:article_id>代表这是一个整数变量，且变量名与对应views中的处理方法传递的参数相同;name是表示别名
]
```

## Objects

模型的objects是获取哦操作模型的对象

```python
Article.objects.get(条件)
Article.objects.all()
Article.objects.filter(条件)
```

### objects.get()

```python
from django.shortcuts import render
from django.http import HttpResponse
from .models import Article

# Create your views here.
def article_detail(request,article_id):
	article = Article.objects.get(id=article_id)  # 创建一个名为article的对象
	return HttpResponse("<h2>文章标题： %s </h2> <br>文章内容： %s " % (article.title,article.content)) 
	#使用article对象中的title属性
```

#### .get()方法错误异常处理

try、except

```
from django.shortcuts import render
from django.http import HttpResponse,Http404
from .models import Article

# Create your views here.
def article_detail(request,article_id):
	try:    #使用try  except  处理异常
		article = Article.objects.get(id=article_id)  # 创建一个名为article的对象
	except Article.DoesNotExist:
		#return HttpResponse("不存在")
		raise Http404("not exist")
	return HttpResponse("<h2>文章标题： %s </h2> <br>文章内容： %s " % (article.title,article.content)) 
	#使用article对象中的title属性
```

get_object_or_404处理异常，如果查询的对象不存在的话，会抛出一个Http404的异常

```python
from django.shortcuts import render,render_to_response,get_object_or_404 
from .models import Article

def article_detail(request,article_id):
		article = get_object_or_404(Article,pk=article_id) #两个参数，1、模型；2、条件主键
		context = {}
		context ['article_obj'] = article 
		return render_to_response("article_detail.html",context) 
```



## 使用模板

1. 在mysite/article下新建文件夹<templates>

2. 在templates文件中新建HTML文件“article_detail.html"

   ```
   <!DOCTYPE html>
   <html>
   <head>
   	<title></title>
   </head>
   <body>
   	<h2>{{article_obj.title}}</h2>
   	<hr>
   	<p>{{article_obj.content}}</p>
   </body>
   </html>
   ```

   其中`{{}}`中的内容用于传递参数

> 查找翻看Django源代码，在Python的安装路径下/Lib/site-packages/django/包名



## 获取文章列表

1. 在urls.py中配置路径

2. 在views.py中新建方法

3. 在HTML模板中使用for语句和url标签

   ```html
   {% for article in articles %}  <!-- 模板中的for语句 -->
   <!-- <a href="/article/{{article.pk}}">{{article.title}}</a> -->
   <a href="{% url 'article_detail' article.pk %}">{{article.title}}</a>   <!-- 模板中的URL标签 -->
   {% endfor %}
   ```



## 总urls包含app的urls

1. 在“article”APP中新建APP的urls.py文件
2. 在总路由urls.py文件中使用include将article中的urls引用过来

```python
# article/urls.py
from django.urls import path
from . import views

urlpatterns = [
	#localhost:8000/article/
    path('<int:article_id>', views.article_detail, name="article_detail"), #本行中的<int:article_id>代表这是一个整数变量，且变量名与对应views中的处理方法传递的参数相同;name是表示别名
    #localhost:8000/article/1
    path('', views.article_list, name="article_list"), 
]
```

```python
# 修改总路由urls.py文件的内筒，使用include
from django.contrib import admin
from django.urls import path,include
from . import views
from article.views import article_detail,article_list

urlpatterns = [
    path('admin/', admin.site.urls),#后台管理网址
    path('', views.index),   #设置一个空的路由，不设置就是ip后没有目录，需要创建一个方法
    path('article/', include('article.urls')), #使用include引用app中的urls.py
]
```



# 五、定制后台和修改模型

https://www.bilibili.com/video/BV1LW411877A/

## 定制admin后台

设置模型\__str__

### 修改article/modles.py

```python
from django.db import models
# Create your models here.
class Article(models.Model):
	title = models.CharField(max_length=30) 
	content = models.TextField()  #用了两种字段模型来穿件类中的两个属性

	def __str__(self):  #在这个类中添加一个方法  标注具体是什么对象
		return "<Article: %s>" % self.title
```

### 修改article/admin.py

```python
from django.contrib import admin
from .models import Article

# Register your models here.在这里注册你的模型
class ArticleAdmin(admin.ModelAdmin):
	list_display = ("title","content")  #元组或列表  最好元组

admin.site.register(Article,ArticleAdmin)
```

修改前的admin界面：

![](https://raw.githubusercontent.com/GittenHub/GittenPicRepo/master/20200705233931.png)

修改后：

![](https://raw.githubusercontent.com/GittenHub/GittenPicRepo/master/20200706133259.png)

### 修改id排序（降序、升序）：

#### 在admin.py中修改

```python
class ArticleAdmin(admin.ModelAdmin):
	list_display = ("id","title","content")  #元组或列表  最好元组
	ordering = ("id",)  #注意在这要加一个逗号，代表是一个元组，否则识别为普通括号
  #ordering = ("-id",)  #倒序
```

#### 在models.py中修改



## 修改模型

> 修改模型后需要生成迁移文件，再迁移
>
> ` python manage.py makemigrations`
>
> ` python manage.py migrate`

> 修改模型前备份数据库

### 让文章显示创建日期的三种方法（设置默认值）

1. 修改models.py，在Article类中增加属性`created_time = models.DateTimeField()`，然后在admin.py中的ArticleAdmin中的list_display属性元组中增加"created_time"字段，迁移启动服务器后，在终端中设置：选择1，输入timezone.now
2. 修改admin.py直接在Article类中增加属性`created_time = models.DateTimeField(default=timezone.now)`设置默认值为现在的日期（记得import）
3. 在`models.DateTimeField(auto_now_add = True) `使用默认参数`auto_now_add = True`



### 外键 作者的名称

Django自带用户模型，在模型中的Article类中新增author属性，用models.ForeignKey()关联外键到User库

```python
#article/models.py/Article
from django.contrib.auth.models import User   #引入用户包

class Article(models.Model):
    author = models.ForeignKey(User, on_delete=models.DO_NOTHING, default=1) 
	#几个参数：1、关联到哪个表；2、文章删除时是否删除作者；3、默认值，在这作者对应的外键的值

```

再在admin.py中增加"author"

### 文章逻辑删除

```python
#article/models.py/Article
from django.db import models

class Article(models.Model):
    is_deleted = models.BooleanField(default=False)  #逻辑删除，而不是真实在数据库中删除
	readed_num = models.IntegerField(default=0)  #阅读量
```

再在admin.py中增加"is_deleted"、""

文章列表（http://127.0.0.1:8000/article/）中不显示逻辑删除的文章：

```python
#article/views.py
def article_list(request):
	articles = Article.objects.filter(is_deleted = False)  #只筛选出未逻辑删除的文章
```





# 六、开始完整制作网站

动力影响学习的热情



## 如何用Django开发网站

要做什么

设计网站圆形

具体开发

测试

部署上线



业务流程

功能木块

前端布局

后端模型



## 接下来的教程

### 目的

1. 通过完整的开发过程学习Django
2. 对一般的网站开发有全面的认识

### 个人博客网站

- 项目管理
  - IDE
  - 本地虚拟环境
  - Git/Github

- 前端开发
  - HTML + JavaScript + CSS
  - jQuery
  - Bootstrap
  - ajax
- 后端开放
  - 博客管理和展示
  - 用户登录和注册
  - 评论和回复
  - 点赞
- 数据库和服务器
  - MySQL
  - linux（centos、Ubuntu）
  - 网站部署

### IDE

记事本

vim/Emacs

sublime text

PyCharm



# 七、构建个人博客网站

## （一）简单构建

网站的功能模块：

- 博客
  - 博文
  - 博客分类
  - 博客标签
- 评论
  - 
- 点赞
- 阅读
- 用户-->第三方登录（QQ/微博）

> 功能模块 ≈ Django App



## （二）开启本地虚拟环境

隔开python项目的运行环境

1. 避免多个项目之间python库的冲突
2. 完整便捷到处python库的列表

`$ pip install virtualenv`

## （三）virtualenv的使用方法

- 创建：`virtualenv<虚拟环境名称>`
- 启动：`$ cd 虚拟环境名称\Scripts\activate`  
- 退出：`deactivate`

## （四）初步创建blog应用

博文 + 博客分类

- 一篇博客一种分类，本教程采用这种
- 一篇博客多种分类

```
django-admin startproject mysite
python manage.py startapp blog
python manage.py migrate
python manage.py createsuperuser
```

> 用户名：gitten
>
> 密码：guoyiteng



## （五）pip一键导出和安装（拓展）

`pip freeze > requirements.txt`

`pip install -r requirements.txt`



# 八、常用的模版标签和过滤器

## （一）继续搭建blog

- [x] models 
- [x] admin
- [ ] views
- [ ] urls
- [ ] templates

在blog/models.py中新建两个类

在blog/views.py中新建两个方法

在blog文件夹下新建templates文件夹，再在templates中新建blog_list.html和blog_detail.html

在blog文件夹下新建urls.py文件，再在总urls.py文件中做好路由映射

## （二）常用的模板标签

- 循环： for
- 条件： if（可逻辑判断）、ifequal、ifnotequal
- 链接： url
- 模板嵌套：block、extends、include
- 注释：{# #}

### 标签

```html
 <h3>{{ blog.title }}</h3>   
{% url 'blog_detail' blog.pk %}
```

两种均为标签

## （三）常用的过滤器

- 日期：date
- 字数截取：truncatechars、truncatechars_html、truncatewords、truncatewords_html
- 是否信任html：safe
- 长度：length

> 参考：https://docs.djangoproject.com/zh-hans/2.0/ref/templates/builtins/

```html
<p>一共有{{ blogs|length }}篇博客</p>
<p>发表日期：{{ blog.created_time|date:"Y-m-d h:n:s" }}</p>
```

### 在templates中的html里使用过滤器

```html
<p>{{ blog.content|truncatechars:30 }}</p>   <!-- 过滤器，显示前30个字符 -->
<p>{{ blog.content|truncatewords:30 }}</p>   <!-- 过滤器，显示前30个英文单词，空格隔开 -->
```





# 九、模板嵌套

## （一）常用的模板标签

- 循环： for
- 条件： if（可逻辑判断）、ifequal、ifnotequal
- 链接： url
- 模板嵌套：block、extends、include
- 注释：{# #}

## （二）全局模板文件夹

在mysite总目录下新建templates文件夹

然后修改 settings.py -->TEMPLATES --> DIRS

```python
'DIRS': [
            os.path.join(BASE_DIR, 'templates'),    #定义全局模板文件夹路径
        ],
```



## （一）模板文件设置建议

- app模板文件 --> app
- project模板文件 --> project



# 十、使用CSS美化页面

## （一）页面设计

- 导航栏
- 主题内容
- 尾注

### 导航栏设计

LOGO网站名称 + 导航

xxxxx的网站   首页  博客

## （二）使用CSS

CSS ：层叠样式表   修饰HTML

韩顺平老师  学习html+css   w3cschool

##  （三）使用静态文件

CSS代码  -->  CSS文件（js文件、图片）  统称为静态文件

设置静态文件的路径，在settings.py最后增加

```python
STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'static'),   #设置静态文件的路径
]
```



### 方法一：直接在HTML模板中引入css

```html
<link rel="stylesheet" type="text/css" href="/static/base.css">
```

### 方法二：load staticfiles

在模板文件中

```html
{% load staticfiles %}

<link rel="stylesheet" type="text/css" href="{% static 'base.css' %}">
{% block header_extends %}{% endblock %}
```

```html
{% load staticfiles %}

{% block header_extends %}
    <link rel="stylesheet" type="text/css" href="{% static 'home.css'%}">
{% endblock %}
```



# 十一、CSS框架协助前段布局

## （一）为什么用CSS框架

1. 不会或不怎么会CSS
2. 不知道如何设计前段样式
3. 从头到尾写整个网站的CSS代码量大
4. ...

##  （二）如何选择CSS框架

- 易用性
- 兼容性
- 大小
- 效果
- 功能

### bootstrap

- 文档齐全，使用简单
- 兼容较多浏览器
- 非轻量级
- 扁平、简洁
- 组件齐全、响应式

## （三）部署Bootstrap

1. 打开bootstrap[www.bootcss.com](www.bootcss.com)
2. 下载bootstrap（选择用于生产环境的bootstrap）
3. 引用bootstrap
4. 开始使用

### bootstrap基本模板

1. 中文语言设置

   ```HTML
   <html lang="zh-CN">
   ```

2. 头信息设置

   ```html
   <meta charset="utf-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">  
   <!-- 告诉ie浏览器使用什么内核 -->
   <meta name="viewport" content="width=device-width, initial-scale=1">
   <!-- 响应式布局 -->
   ```

   

# 十二、Bootstrap响应式布局

> 同时打开两个Django项目的runserver
>
> `python manage.py runserver 8001  #默认为8080端口，设置其他端口则直接加在最后`

## （一）Bootstrap的响应式设计

适应4种屏幕大小，12列布局

- <768px （手机）
- \>=768px （平板）
- \>=992px （小尺寸显示器）
- \>=1200px （大尺寸显示器）

### 栅格参数

通过下表可以详细查看 Bootstrap 的栅格系统是如何在多种屏幕设备上工作的。

|                       | 超小屏幕 手机 (<768px)     | 小屏幕 平板 (≥768px)                                | 中等屏幕 桌面显示器 (≥992px) | 大屏幕 大桌面显示器 (≥1200px) |
| :-------------------- | :------------------------- | :-------------------------------------------------- | :--------------------------- | :---------------------------: |
| 栅格系统行为          | 总是水平排列               | 开始是堆叠在一起的，当大于这些阈值时将变为水平排列C |                              |                               |
| `.container` 最大宽度 | None （自动）              | 750px                                               | 970px                        |            1170px             |
| 类前缀                | `.col-xs-`                 | `.col-sm-`                                          | `.col-md-`                   |          `.col-lg-`           |
| 列（column）数        | 12                         |                                                     |                              |                               |
| 最大列（column）宽    | 自动                       | ~62px                                               | ~81px                        |             ~97px             |
| 槽（gutter）宽        | 30px （每列左右均有 15px） |                                                     |                              |                               |
| 可嵌套                | 是                         |                                                     |                              |                               |
| 偏移（Offsets）       | 是                         |                                                     |                              |                               |
| 列排序                | 是                         |                                                     |                              |                               |

### 布局容器

Bootstrap 需要为页面内容和栅格系统包裹一个 `.container` 容器。我们提供了两个作此用处的类。注意，由于 `padding` 等属性的原因，这两种 容器类不能互相嵌套。

`.container` 类用于固定宽度并支持响应式布局的容器。

```
<div class="container">
  ...
</div>
```

`.container-fluid` 类用于 100% 宽度，占据全部视口（viewport）的容器。

```
<div class="container-fluid">
  ...
</div>
```



## （二）基本结构

```html
<div class="container">
  	<div class="row">
	      <div class="col-xx-*"></div>
      	<div class="col-xx-*"></div>
	  </div>
</div>
```





## （三）Django静态文件命名空间

为了避免冲突

可以在app文件夹下的static文件夹中心间app名称的文件夹，再将css等静态文件放入其中，在应用css前加`static/app/xxx.css`



# 十三、分页和shell命令行模式

## （一）为什么先将分页功能

1. 新增或编辑博客内容

2. 博客文章数较多->全部加载过慢->分页加载

   为了夯实基础，借机讲shell模式、模型操作、模版标签、分页器

## （二）快速添加博客

### shell命令行模式添加博客

1. `python manage.py shell`
2. `for`循环执行新增博客代码

## （三）模型新增对象

```python
from blog.models import Blog
blog = Blog()
blog.title = 'xxx'
...
blog.save()
```

### terminal操作

```python
Last login: Mon Jul 13 14:12:14 on ttys000
gitten@Gittens-Macbook mysite % conda activate django2.0
(django2.0) gitten@Gittens-Macbook mysite % python manage.py shell
Python 3.8.3 (default, Jul  2 2020, 11:26:31) 
[Clang 10.0.0 ] on darwin
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
>>> from blog.models import Blog
>>> dir()
['Blog', '__builtins__']
>>> Blog.objects.all()
<QuerySet [<Blog: Blog: 长内容的博客>, <Blog: Blog: 随笔2>, <Blog: Blog: Django1>]>
>>> Blog.objects.count()
3
>>> Blog.objects.all().count()
3
>>> blog = Blog()
>>> dir()
['Blog', '__builtins__', 'blog']
>>> Blog.objects.all()
<QuerySet [<Blog: Blog: 长内容的博客>, <Blog: Blog: 随笔2>, <Blog: Blog: Django1>]>
>>> blog.title = "shell下第1篇"
>>> blog.content = "xxxxxx"
>>> from blog.models import BlogType
>>> BlogType.objects.all()
<QuerySet [<BlogType: Django>, <BlogType: 随笔>, <BlogType: 感悟>]>
>>> BlogType.objects.all()[0]
<BlogType: Django>
>>> blog_type = BlogType.objects.all()[0]
>>> blog.blog_type = blog_type
>>> from django.contrib.auth.models import User
>>> User.objects.all()
<QuerySet [<User: gitten>]>
>>> user = User.objects.all()[0]
>>> blog.author = user
>>> blog.save()
>>> Blog.objects.all()
<QuerySet [<Blog: Blog: 长内容的博客>, <Blog: Blog: 随笔2>, <Blog: Blog: Django1>, <Blog: Blog: shell下第1篇>]>
>>>
>>>
>>>
>>>
>>> for i in range(1,31):
...     blog = Blog()
...     blog.title = "for %s" %i
...     blog.content = "xxxxx:%s" % i
...     blog.blog_type = blog_type
...     blog.author = user
...     blog.save()
... 
>>> Blog.objects.all().count()
34
```

## （四）分页器实现分页

![](https://gitee.com/gitten/PicBed/raw/master/20200714102155.png)



```python
(django2.0) gitten@Gittens-Macbook mysite % python manage.py shell
Python 3.8.3 (default, Jul  2 2020, 11:26:31) 
[Clang 10.0.0 ] on darwin
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
>>> dir()
['__builtins__']
>>> from django.core.paginator import Paginator
>>> from blog.models import Blog
>>> blogs = Blog.object.all()
Traceback (most recent call last):
  File "<console>", line 1, in <module>
AttributeError: type object 'Blog' has no attribute 'object'
>>> blogs = Blog.objects.all()
>>> blogs.count()
34
>>> paginator = Paginator(blogs,10)
<console>:1: UnorderedObjectListWarning: Pagination may yield inconsistent results with an unordered object_list: <class 'blog.models.Blog'> QuerySet.
# 这里报了一个错误，是因为我们在models中没有设置默认排序方式，去修改
>>> 
```

### 修改models.py的默认排序方式

## （五）分页的使用

前端：发送请求，请求打开具体分页内容

后端：处理情况，返回具体分页内容相应情况

` http://127.0.0.1:8000/blog/?page=4`中的`?page=4`表示GET传递的参数





# 十四、 优化分页展示

## （一）优化页面展示

友好的用户体验

1. 当前页面高亮
2. 不好过多页码选择，影响布局



> shift + F5  ： 强制刷新服务器



## （二）settings自定义设置

公用全局设置可放在settings中，统一管理

`from django.conf import settings`

`settings.XXX`



# 十五、上下篇博客和按月分类



## （一）上一篇和下一篇博客

对比当前博客，得到上一篇或下一篇

##  （二）filter筛选条件

等于：直接筛选

其他常用查找类型：

- 大于：__gt(greater than)

  ```python
  context['previous_blog'] = Blog.objects.filter(created_time__gt=blog.created_time).last()  
  #取创建时间比当前博客大的博客列表中的最后一条
  ```

- 大于等于：__gte

- 小于：__lt(less than)

- 小于等于：__lte

  > 上述这些大多用于数字的比较

- 包含：__contains(加i忽略大小写)

  ```python
  >>> from blog.models import Blog
  >>> Blog.objects.filter(title__contains='django')
  <QuerySet [<Blog: Blog: Django1>]>   #因为sqlite不区分大小写，所以也筛选出来了
  >>> Blog.objects.filter(title__icontains='django')
  <QuerySet [<Blog: Blog: Django1>]>
  ```

- 开头是：__startswith

- 结尾是：__endswith

  > 字符串大多用饱含、开头是、结尾是

- 其中之一：__in

- 范围：__range

  ```python
  >>> Blog.objects.filter(id__in=[1, 3, 4])
  <QuerySet [<Blog: Blog: 随笔2>, <Blog: Blog: 长内容的博客>]>
  >>> Blog.objects.filter(id__range=(3, 6))
  <QuerySet [<Blog: Blog: shell下第1篇>, <Blog: Blog: Django1>, <Blog: Blog: 随笔2>, <Blog: Blog: 长内容的博客>]>
  ```

## （三）exclude排除条件

filter无法去筛选“不符合某种条件”的对象

exclude的用法和filter一样，都是得到查询（QuerySet）

相当于filter条件取反

filter等于 => 不等于

```python
>>> Blog.objects.exclude(pk=3)   # 筛选出pk不等于3的博客
<QuerySet [<Blog: Blog: for 30>, <Blog: Blog: for 29>, <Blog: Blog: for 28>, <Blog: Blog: for 27>, <Blog: Blog: for 26>, <Blog: Blog: for 25>, <Blog: Blog: for 24>, <Blog: Blog: for 23>, <Blog: Blog: for 22>, <Blog: Blog: for 21>, <Blog: Blog: for 20>, <Blog: Blog: for 19>, <Blog: Blog: for 18>, <Blog: Blog: for 17>, <Blog: Blog: for 16>, <Blog: Blog: for 15>, <Blog: Blog: for 14>, <Blog: Blog: for 13>, <Blog: Blog: for 12>, <Blog: Blog: for 11>, '...(remaining elements truncated)...']>
```

##4、条件中的双下划线

1. 字段查询类型
2. 外键拓展（以博客分类为例）
3. 日期拓展（以月份分类为例）
4. 支持链式查询：可以一直链接下去

# 十六、博客分类统计

## （一）annotat注释

使用annotate拓展查询字段

```python
context['blog_types'] = BlogType.objects.annotate(blog_count=Count('blog'))
```



# 十七、 博客后台富文本编辑

## （一）使用html丰富页面

- 简繁文本编辑
  - 直接贴入html代码
- 富文本编辑
  - 最终解析成html
    - 富文本编辑器
    - markdown编辑器

### 直接贴入html

直接写入因为安全问题，无法识别为html语言，需要在模板文件中修改修饰器`{{ blog.content|safe }}`在后面增加safe

```python
<div class="blog-content">{{ blog.content|safe }}</div>   
```

但此时列表中的内容简述会有html语句

在列表html文件中修改模板文件，增加修饰器`|striptags`，表示忽略html标签

```django
<p>{{ blog.content|striptags|truncatechars:120 }}</p>
```

## （二）使用django-ckeditor富文本编辑器

**选择标准：**

- 具有基本的富文本编辑功能
- 可以上传图片
- 可以查看源码
- 有持续更新（维护）

## （三）安装django-ckeditor

1. 安装

   `pip install django-ckeditor`

2. 注册应用

   'ckeditor'

3. 配置model

   把字段改为RichTextField

> Django-ckeditor在语言设置为zh-Hans时有识别错误为繁体，改为zh-hans就可以了

## （四）添加上传图片功能

1. 安装

   `pip install pillow`  pillow是一个用于处理图片的库

2. 注册应用

   ```
    INSTALLED_APPS = [
       'ckeditor_uploader',
   ]
   ```

3. 配置settings.py，在最后增加

   ```python
   # media配置
   MEDIA_URL = '/media/'
   MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
   
   # 配置ckeditor
   CKEDITOR_UPLOAD_PATH = 'upload/'
   ```

4. 配置url.py

   ```python
   urlpatterns = [
       path('ckeditor', include('ckeditor_uploader.urls')),
   ]
   
   urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
   ```

5. 配置model

   此时models类中仍不能上传文件，将其修改至如下：

   ```python 
   from ckeditor_uploader.fields import RichTextUploadingField
   
   class Blog(models.Model):  
       content = RichTextUploadingField()
   ```

> 这些配置都可以在pypi.python.org网站中找到，搜索'django-ckeditor'



# 十八、博客阅读简单计数

## （一）简单计数处理

1. Blog模型添加数字字段记录
2. 每次有人打开，记录数+1

## （二）自定义技术规则

可规定，怎么才算阅读一次

1. 无视是否同一人，每次打开都记录
2. 若同一个人，每隔多久才算阅读一次

```python
def blog_detail(request,blog_pk):
    blog = get_object_or_404(Blog, pk=blog_pk)
    if not request.COOKIES.get('blog_%s_readed' % blog_pk):
        blog.readed_num += 1
        blog.save()
    context = {}
    context['blog'] = blog
    context['previous_blog'] = Blog.objects.filter(created_time__gt=blog.created_time).last()  # 取创建时间比当前博客大的博客列表中的最后一条
    context['next_blog'] = Blog.objects.filter(created_time__lt=blog.created_time).first()  # 取创建时间比当前博客小的博客列表中的第一条｜可以将first()替换为[0]进行切片
    response = render_to_response('blog/blog_detail.html',context)  # 响应
    #response.set_cookie('blog_%s_readed' % blog_pk, 'true', max_age=60, expires=datetime()) # max_age有效时间以秒计,expires设置一个datetime，两者冲突
    response.set_cookie('blog_%s_readed' % blog_pk, 'true')
    return response
```



## （三）该技术方法缺点

1. 后台编辑博客可能影响数据

   更新时会影响统计，同时访问时会影响编辑最后时间

1. 功能单一，无法统计某一天的阅读量



# 十九、博客阅读计数优化

## （一）简单计数方法的缺点

1. 后台编辑博客可能影响数据

   更新时会影响统计，同时访问时会影响编辑最后时间

1. 功能单一，无法统计某一天的阅读量

## （二）计数功能独立

- 博客内容 Blog
- 计数字段 Read Num
- 通过外键关联起来

![](https://gitee.com/gitten/PicBed/raw/master/20200725140250.png)

### 在model.py中新建一个类

```python
class ReadNum(models.Model):
    read_num = models.IntegerField(default=0)
    blog = models.OneToOneField(Blog, on_delete=models.DO_NOTHING)  
    # OneToOneField表示一对一，ForeignKey表示多对一，ManyToManyField表示多对多;on_delete 删除阅读数时是否删除博客;
```

### 迁移数据库文件

### 编辑admin.py

```python
@admin.register(ReadNum)
class ReadNumAdmin(admin.ModelAdmin):
    list_display = ('read_num', 'blog')
```

### django多对一模型间的关系

![](https://gitee.com/gitten/PicBed/raw/master/20200725141445.png)

> `Blog.objects.first().blog_type.blog_set.all()`可查看第一条博客所属类型的所有博客

### ReadNum与Blog外键关联后，可通过小写相互调用

`Blog.objects.first().readnum` 可返回ReadNum的对象

`Blog.objects.first().readnum.read_num` 可返回第一条博客的阅读数

### 在Blog中增加一个方法`get_read_num`

```python
class Blog(models.Model):
		...
    def get_read_num(self):
        try:
            return self.readnum.read_num   # 在将Blog和ReadNum关联后可以通过小写的方式调用另一个类的属性
        except exceptions.ObjectDoesNotExist as e: # 如果返回错误是对象不存在，则
            return 0
        
```

### 判断是否阅读过，修改views.py中的blog_detail方法

```python
def blog_detail(request,blog_pk):
    blog = get_object_or_404(Blog, pk=blog_pk)
    if not request.COOKIES.get('blog_%s_readed' % blog_pk):
        if ReadNum.objects.filter(blog=blog).count():   # 等于0为false，不为零就是true
            # 存在记录
            readnum = ReadNum.objects.get(blog=blog)    
        else:
            # 不存在对应的记录
            readnum = ReadNum(blog=blog)
        # 计数加一
        readnum.read_num += 1
        readnum.save()

    context = {}
    context['blog'] = blog
    context['previous_blog'] = Blog.objects.filter(created_time__gt=blog.created_time).last()  # 取创建时间比当前博客大的博客列表中的最后一条
    context['next_blog'] = Blog.objects.filter(created_time__lt=blog.created_time).first()  # 取创建时间比当前博客小的博客列表中的第一条｜可以将first()替换为[0]进行切片
    response = render_to_response('blog/blog_detail.html',context)  # 响应
    #response.set_cookie('blog_%s_readed' % blog_pk, 'true', max_age=60, expires=datetime()) # max_age有效时间以秒计,expires设置一个datetime，两者冲突
    response.set_cookie('blog_%s_readed' % blog_pk, 'true') 
    return response
```

## （三）可以对任意模型计数

![](https://gitee.com/gitten/PicBed/raw/master/20200725144433.png)

### ContentType：

记录了Django中所有模型，建立了一个表（也就是模型ContentType）

### 创建新的app：read_statistics

```python 
python manage.py startapp
```

注册新的app

### 修改阅读计数app下的models

```python
from django.db import models
from django.contrib.contenttypes.fields import GenericForeignKey
from django.contrib.contenttypes.fields import ContentType

class ReadNum(models.Model):
    read_num = models.IntegerField(default=0)

    content_type = models.ForeignKey(ContentType, on_delete=models.DO_NOTHING)
    # 关联外键到ContentType，再通过ContentType关联到相应的其他模型
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey('content_type', 'object_id') # 将上述两个属性结合创建一个外键
```

> Python 代码规范：先官方库 > 第三方库 > 我们自己的

迁移文件，在admin界面显示

### 通过shell分析Blog、ContentType、ReadNum三者间的关系

![image-20200725152905864](/Users/gitten/Library/Application Support/typora-user-images/image-20200725152905864.png)

ContentType 居中将Blog、ReadNum链接在一起

其中关键语句为`content_type = models.ForeignKey(ContentType, on_delete=models.DO_NOTHING)`

### 新建ReadNumExpandMethod，并让blog/models中的Blog继承这个类

ReadNumExpandMethod：

```python
from django.db import models
from django.db.models.fields import exceptions

class ReadNumExpandMethod():
    def get_read_num(self):
        try:
            ct = ContentType.objects.get_for_model(self)
            readnum = ReadNum.objects.get(content_type=ct, object_id=self.pk)
            return readnum.read_num
        except exceptions.ObjectDoesNotExist:
            return 0
```

ReadNumExpandMethod通过try来判断时候ReadNum中有博客对应的阅读数，有的话返回值，没有的话返回0

blog/models/Blog:

```python
from read_statistics.models import ReadNumExpandMethod

class Blog(models.Model, ReadNumExpandMethod): # 继承ReadNumExpandMethod中的属性
  	...
```

Blog继承ReadNumExpandMethod类中的get_read_num方法

此时blog/admin中就可以直接新增" get_read_num "了

```python
@admin.register(Blog)
class BlogAdmin(admin.ModelAdmin):
    list_display = ('id', 'title', 'blog_type', 'author', 'get_read_num', 'created_time', 'last_updated_time') 
```

### 在read_statistics中新建utils.py作为工具包

```python
from django.contrib.contenttypes.models import ContentType
from .models import ReadNum

def read_statistic_once_read(request, obj):
    ct = ContentType.objects.get_for_model(obj)
    key = "%s_%s_read" % (ct.model, obj.pk)
    if not request.COOKIES.get(key):
        if ReadNum.objects.filter(content_type=ct, object_id=obj.pk).count():   # 等于0为false，不为零就是true
            # 存在记录
            readnum = ReadNum.objects.get(content_type=ct, object_id=obj.pk)    
        else:
            # 不存在对应的记录
            readnum = ReadNum(content_type=ct, object_id=obj.pk)
        # 计数加一
        readnum.read_num += 1
        readnum.save()
    return key
```

`read_statistic_once_read`方法接受request和一个类中的具体对象，判断是否有cookie，没有的话readnum自增1，并返回key，由views.py中的blog_detail设置cookie



# 二十、阅读计数统计和显示

## （一）简单计数方法的缺点

1. 后台编辑博客可能影响数据

1. 功能单一，无法统计某一天的阅读量

##  （二）统计需要记录明细



## （三）使用图表显示数据

后台 + 前端

后台提供数据，前段使用数据

使用highcharts：www.hcharts.cn





# 二十一、热门阅读博客排行及缓存提速

## （一）利用阅读量数据排行

- 24小时内 -> 今天数据统计
- 昨天 -> 昨天数据统计
- 一周
- 30天



### 一周

`objects.values()`可以按照该对象的属性与属性的值，转为键值对的list

再用annotate可对键值对list进行分组统计，annotate中的参数为`sum()`或`count()`等方法

#### 反向通用关系 GenericRelation

在blog/models.py中新增一个属性

```python
from django.db import models
from django.contrib.contenttypes.fields import GenericRelation

class Blog(models.Model, ReadNumExpandMethod):
    ...
    read_details = GenericRelation(ReadDetail) # 反向通用关系，这运河之后可直接调用对方了
    ...
```





## （二）每次都计算，耗时

策略：缓存数据，不用每次都计算

- 内存缓存：Memcached、Redis
- 数据库缓存
- 文件缓存

> 缓存：Django官网搜索  " cache "

### 设置settings.py

```python
# 数据库缓存设置
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.db.DatabaseCache',
        'LOCATION': 'my_cache_table',
    }
}
```

### 在views.py中import cache

```python
from django.core.cache import cache

hot_blogs_for_7_days = cache.get('hot_blogs_for_7_days')
if hot_blogs_for_7_days is None:
  hot_blogs_for_7_days = get_7_days_hot_blogs()
  cache.set('hot_blogs_for_7_days', hot_blogs_for_7_days, 3600)  #最后一个为有效期（秒）
  print('calc')
else:
  print('use cache')
```



# 番外篇：在pythonanywhere部署Django

教程网址：https://www.bilibili.com/video/BV1wW411p7hh/

进一步激发学习的激情

## 部署上线常见主机

1. pythonanywhere、heroku
2. 云主机：阿里云、亚马逊等等

pythonanywhere网址：www.pythonanywhere.com





# 二十二、评论功能设计和用户登录

## （一）实现评论功能的方式

1. 第三方社会化评论插件
   1. 友言、多说、倡言、Disqus、网易云跟帖
2. Django评论库
   1. django-comment
3. 自己写代码实现

## （二）创建评论模型

- 评论对象
- 评论内容
- 评论时间
- 评论者

startapp comment

Class comment

@admin.register(Comment)



## （三）评论需要登录用户

确保较低程度减少垃圾评论

也提高了评论员门槛（第三方登录）

还可以通知用户

### 在模板页面设置 【提交评论区】【评论列表】

```django
<div class="row">
  <div class="col-xs-10 col-xs-offset-1">
    <div style="margin-top: 2em;border: 1px dashed;padding: 2em;">提交评论区
      {% if user.is_authenticated %}
      已登录
      {% else %}
      未登录
      <form action="{% url 'login' %}" method="POST">
        {% csrf_token %}
        <input type="text" name="username">
        <input type="password" name="password">
        <input type="submit" value="登录">
      </form>
      {% endif %}
    </div>
    <div style="margin-top: 2em;border: 1px dashed;padding: 2em;">评论列表区</div>
  </div>
</div>
```

### 在urls.py中设置路由

```python
urlpatterns = [
    ...
    path('login/', views.login, name='login'),
]
```

### 在views.py中设置login登录方法

```python
from django.shortcuts import render, redirect
from django.contrib import auth

def login(request):
    username = request.POST.get('username', '')
    password = request.POST.get('password', '')
    user = auth.authenticate(request, username=username, password=password)
    if user is not None:
        auth.login(request, user)
        return redirect('/')
        
    else:
        return render(request, 'error.html', {'messeage':'用户名密码不正确'})
```

### 设置error.html

```django
{% extends 'base.html' %}
{% load staticfiles %}

{# 页面标题 #}
{% block title %}
    我的网站｜错误
{% endblock %}

{% block nav_home_active %}active{% endblock %}

{% block content %}
    {{ message }}
{% endblock %}
```





# 二十三、HTML表单提交评论

## （一）提交评论

- 评论对象
- 评论内容
- 评论时间
- 评论者

### 重定向：登录后自动跳转至刚才浏览的页面

mysite/views.py中使用redirect(referer)进行重定向  

```python
def login(request):
    username = request.POST.get('username', '')
    password = request.POST.get('password', '')
    user = auth.authenticate(request, username=username, password=password)
    #referer = request.META.get('HTTP_REFERER', '/')
    referer = request.META.get('HTTP_REFERER', reverse('home')) #反方向解析别名
    # referer表示，使用请求头META中，用get获取HTTP_REFERER(推荐人)，也就是这个请求前所在的网址, 如果没有HTTP_REFERER则跳转到首页
    # reverse表示进行反向解析，通过对别名home进行解析，得到链接地址
    if user is not None:
        auth.login(request, user)
        return redirect(referer)  # redirect表示进行重定向
    else:
        return render(request, 'error.html', {'message':'用户名密码不正确'})
```

### 在具体博客下方细分“提交评论”和“评论列表”

修改blog_detail.html文件

```django
<div class="row">
            <div class="col-xs-10 col-xs-offset-1">
                <div class="comment-area">
                    <h3 class="comment-area-title">提交评论</h3>
                {% if user.is_authenticated %}
                    <form action="{% url 'update_comment' %}" method="POST" style="overflow:hidden;">
                        {% csrf_token %}
                        <div class="form-group">
                            <label for="comment_text">{{ user.username }}，欢迎评论~</label>
                            <textarea id="comment_text" class="form-control" name="text" rows="4"></textarea>
                        </div>
                        
                        <input type="hidden" name="object_id" value="{{ blog.pk }}">
                        <input type="hidden" name="content_type" value="blog">
                        <input type="submit" value="评论" class="btn btn-primary" style="float:right">
                    </form>
                {% else %}
                    未登录，登录之后方可评论
                    <form action="{% url 'login' %}" method="POST">
                        {% csrf_token %}
                        <input type="text" name="username">
                        <input type="password" name="password">
                        <input type="submit" value="登录">
                    </form>
                {% endif %}
                </div>
                <div class="comment-area">
                    <h3 class="comment-area-title">评论列表</h3>
                    {% for comment in comments%}
                        <div>
                            {{ comment.user.username }}
                            ({{ comment.comment_time|date:"Y-m-d H:n:s" }}):
                            {{ comment.text }}
                        </div>
                    {% empty %}
                        暂无评论
                    {% endfor %}
                </div>
            </div>
        </div>
```

### form表单提交主要结构

```django
<form action="{% url 'update_comment' %}" method="POST" style="overflow:hidden;">
  {% csrf_token %}      {# 防止报错 #}
  <div class="form-group">
    <label for="comment_text">{{ user.username }}，欢迎评论~</label>
    <textarea id="comment_text" class="form-control" name="text" rows="4"></textarea>
  </div>
  <input type="hidden" name="object_id" value="{{ blog.pk }}">
  <input type="hidden" name="content_type" value="blog">
  <input type="submit" value="评论" class="btn btn-primary" style="float:right">
</form>
```

name表示键，value表示值，两者构成键值对，由action专递给路由别名“update_comment”——{% url 'update_comment' %}





### comment/urls.py

```python
urlpatterns = [
    path('update_comment', views.update_comment, name='update_comment'),    
]
```



### 提交表单后views中的函数

comment/views.py

``` python
from django.shortcuts import render, redirect
from django.contrib.contenttypes.models import ContentType
from django.urls import reverse
from .models import Comment


def update_comment(request):
    referer = request.META.get('HTTP_REFERER', reverse('home')) 
    # 转回到请求中的网址

    # 数据检查
    if not request.user.is_authenticated:
    # request.user.is_authenticated表示是否登录   
        return render(request, 'error.html', {'message':'用户未登录', 'redirect_to':referer})

    text = request.POST.get('text', '').strip()  # 获取不到为空
    if text == '':
        return render(request, 'error.html', {'message':'评论内容为空', 'redirect_to':referer})

    try:  # 进行错误处理，有可能content_type、object_id会有错误
        content_type = request.POST.get('content_type', '')
        object_id = int(request.POST.get('object_id', ''))
        model_class = ContentType.objects.get(model=content_type).model_class()
        # 使用ContentType进行处理，根据'content_type'得到blog等对象类型,ContentType.objects.get获得一个外键关联的具体的blog对象
        # 使用model_class方法，可以得到具体的模型的class, 也就是得到Blog；使用model_class方法，可以根据一个具体的object对象，返回这个对象所属的class类
        model_obj = model_class.objects.get(pk=object_id)
    except Exception as e:
        return render(request, 'error.html', {'message':'评论对象不存在', 'redirect_to':referer})

    # 检查通过，保存数据
    comment = Comment()
    comment.user = request.user
    comment.text = text
    comment.content_object = model_obj
    comment.save()

    return redirect(referer)
```



## （二）进一步讲解

django forms类

自定义模板标签



# 二十四、 使用Django Form表单提交

## （一）Django Form的作用

Django用Form类描述html表单，帮助或简化操作

1. 接受和处理用户提交的数据

   检查提交的数据

   可将数据转换成python的数据类型

2. 可自动生成HTML代码

## （二）Django Form的使用

![](https://gitee.com/gitten/PicBed/raw/master/20200728211639.png)

### 在mysite/下新建forms.py文件

```python
from django import forms

class LoginForm(forms.Form):
    username = forms.CharField(label='用户名', required=True) # label可定制html中的label标签; required=True表示这个字段一定要填写才能提交
    password = forms.CharField(label='密码', widget=forms.PasswordInput) # widget=forms.PasswordInput可定义在HTML中生成password类，隐藏密码
```

### 在mysite/views.py文件中`from .forms import LoginForm`，修改Login登录方法

```python
from .forms import LoginForm

def login(request):
    if request.method == 'POST':  # 如果请求中的提交方法为POST
        login_form = LoginForm(request.POST)
        if login_form.is_valid():  # 判断login_form是否有效
            username = login_form.cleaned_data['username']  # cleaned_data 表示是处理过的干净数据
            password = login_form.cleaned_data['password']
            user = auth.authenticate(request, username=username, password=password)
            if user is not None:   # 如果user存在
                auth.login(request, user)  # 登录
                return redirect(request.GET.get('from', reverse('home')))  
                # 利用在HTML模板文件中添加GET请求参数?from=，将之前的页面地址传递过来，如果没有则返回首页
            else:
                # form 自带一个错误集
                login_form.add_error(None, '用户名或密码不正确')  # add_error有两个参数，第一个为错误的参数名（可以为None），后面为文字提示
                context = {}
                context['login_form'] = login_form # 此时login_form携带了上面增加的错误信息
                return render(request, 'login.html', context)
        else:
            pass
    else:
        login_form = LoginForm()
        context = {}
        context['login_form'] = login_form
        return render(request, 'login.html', context)
```

将context['login_form']传递给前端模板页面

### 新建login.html

```django
{% extends 'base.html' %}
{% load staticfiles %}

{# 页面标题 #}
{% block title %}
    我的网站｜登录
{% endblock %}

{% block nav_home_active %}active{% endblock %}

{% block content %}
    <form action="#" method="POST">
        {% csrf_token %}
        {{ login_form }}
        <input type="submit" value="登录">
    </form>
{% endblock %}
```

### 在forms.py中验证用户名密码是否正确

修改forms.py

```python
from django import forms
from django.contrib import auth

class LoginForm(forms.Form):
    username = forms.CharField(label='用户名', required=True, widget=forms.TextInput) 
    # label可定制html中的label标签; required=True表示这个字段一定要填写才能提交
    password = forms.CharField(label='密码', widget=forms.PasswordInput(attrs={'class':'form-control'})) 
    # widget=forms.PasswordInput可定义在HTML中生成password类，以密文的形式隐藏密码.widget可定义这个form中一个字段的类型
    
    # 验证用户名密码是否正确
    def clean(self):
    # views.py中在进行.is_valid()，进行判断LoginForm是否有效时会使用这个方法
        username = self.cleaned_data['username']
        password = self.cleaned_data['password']

        user = auth.authenticate(username=username, password=password) 
        # .authenticate中的第一个参数request是可以不需要的
        if user is None:   
            raise forms.ValidationError('用户名或密码不正确')
            # 抛出错误raise
        else:
            self.cleaned_data['user'] = user
        return self.cleaned_data
            
```

简化views.py

```python
def login(request):
    if request.method == 'POST':  
    # 如果请求中的提交方法为POST，则提交POST中request的内容，否则渲染页面
        login_form = LoginForm(request.POST) # request.POST中包含了username等键值对
        # login_form = LoginForm({'username':'sss'}) 
        if login_form.is_valid():  # 判断login_form是否有效，并进行forms.py中的clean方法
            user = login_form.clean_data['user']
            auth.login(request, user)  # 登录
            return redirect(request.GET.get('from', reverse('home'))) 
            # redirect表示进行重定向 进行页面跳转，跳转到原来的页面，
            # 利用在HTML模板文件中添加GET请求参数?from=，将之前的页面地址传递过来，如果没有则返回首页
            
    else:
        login_form = LoginForm()

    context = {}
    context['login_form'] = login_form # 如果错误，此时login_form携带了上面增加的错误信息
    return render(request, 'login.html', context)
```

### 通过python manage.py shell查看forms的所有属性

```python
>>> from django import forms
>>> dir(forms)
['ALL_FIELDS', 'BaseForm', 'BaseFormSet', 'BaseInlineFormSet', 'BaseModelForm', 'BaseModelFormSet', 'BooleanField', 'BoundField', 'CharField', 'CheckboxInput', 'CheckboxSelectMultiple', 'ChoiceField', 'ClearableFileInput', 'ComboField', 'DateField', 'DateInput', 'DateTimeField', 'DateTimeInput', 'DecimalField', 'DurationField', 'EmailField', 'EmailInput', 'Field', 'FileField', 'FileInput', 'FilePathField', 'FloatField', 'Form', 'GenericIPAddressField', 'HiddenInput', 'ImageField', 'IntegerField', 'Media', 'MediaDefiningClass', 'ModelChoiceField', 'ModelForm', 'ModelMultipleChoiceField', 'MultiValueField', 'MultiWidget', 'MultipleChoiceField', 'MultipleHiddenInput', 'NullBooleanField', 'NullBooleanSelect', 'NumberInput', 'PasswordInput', 'RadioSelect', 'RegexField', 'Select', 'SelectDateWidget', 'SelectMultiple', 'SlugField', 'SplitDateTimeField', 'SplitDateTimeWidget', 'SplitHiddenDateTimeWidget', 'TextInput', 'Textarea', 'TimeField', 'TimeInput', 'TypedChoiceField', 'TypedMultipleChoiceField', 'URLField', 'URLInput', 'UUIDField', 'ValidationError', 'Widget', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', 'all_valid', 'boundfield', 'fields', 'fields_for_model', 'forms', 'formset_factory', 'formsets', 'inlineformset_factory', 'model_to_dict', 'modelform_factory', 'modelformset_factory', 'models', 'renderers', 'utils', 'widgets']
>>> list(filter(lambda x: 'Input' in x,dir(forms)))
['CheckboxInput', 'ClearableFileInput', 'DateInput', 'DateTimeInput', 'EmailInput', 'FileInput', 'HiddenInput', 'MultipleHiddenInput', 'NumberInput', 'PasswordInput', 'TextInput', 'TimeInput', 'URLInput']
>>> list(filter(lambda x: 'Field' in x,dir(forms)))
['BooleanField', 'BoundField', 'CharField', 'ChoiceField', 'ComboField', 'DateField', 'DateTimeField', 'DecimalField', 'DurationField', 'EmailField', 'Field', 'FileField', 'FilePathField', 'FloatField', 'GenericIPAddressField', 'ImageField', 'IntegerField', 'ModelChoiceField', 'ModelMultipleChoiceField', 'MultiValueField', 'MultipleChoiceField', 'NullBooleanField', 'RegexField', 'SlugField', 'SplitDateTimeField', 'TimeField', 'TypedChoiceField', 'TypedMultipleChoiceField', 'URLField', 'UUIDField']
>>> 
```

```
>>> list(filter(lambda x: 'Input' in x,dir(forms)))
# 查看forms中包含Input的所有属性
```



## （三）Form中`.is_valid()`方法校验机制

views.py中定义login函数时，需要对构建的login_form进行校验

```python
def login(request):
    if request.method == 'POST':  
        login_form = LoginForm(request.POST) # request.POST中包含了username等键值对
        if login_form.is_valid():  # 判断login_form是否有效，并进行forms.py中的clean方法
            user = login_form.clean_data['user']
            auth.login(request, user)  # 登录
            return redirect(request.GET.get('from', reverse('home'))) 
    else:
        login_form = LoginForm(
    context = {}
    context['login_form'] = login_form # 如果错误，此时login_form携带了上面增加的错误信息
    return render(request, 'login.html', context)
```

此时在执行`.is_valid()`时，运行的是forms.py文件中LoginForm类进行了多步操作，其中一步是中LoginForm类中的clean方法（或是clean_xxxx)

> 参考：https://blog.csdn.net/weixin_43819222/article/details/94176820

```python
class LoginForm(forms.Form):
    username = forms.CharField(label='用户名', required=True, 
                               widget=forms.TextInput(attrs={'class':'form-control', 'placeholder':'请输入用户名'})) 
    password = forms.CharField(label='密码', widget=forms.PasswordInput(attrs={'class':'form-control', 'placeholder':'请输入密码'})) 
    def clean(self):
        username = self.cleaned_data['username']
        password = self.cleaned_data['password']
        user = auth.authenticate(username=username, password=password) 
        if user is None:   
            raise forms.ValidationError('用户名或密码不正确')
        else:
            self.cleaned_data['user'] = user
        return self.cleaned_data
```



# 二十五、富文本编辑和ajax提交评论

## （一）django-ckeditor富文本表单

![](https://gitee.com/gitten/PicBed/raw/master/20200803220152.png)



### （1）使用form表单修改评论功能

1.在comment文件夹下新建forms.py文件

```python
from django import forms
from django.contrib import auth
from django.contrib.auth.models import User

class CommentForm(forms.Form):
    content_type = forms.CharField(widget=forms.HiddenInput) # HiddenInput在前端隐藏显示
    object_id = forms.IntegerField(widget=forms.HiddenInput)
    text = forms.CharField(widget=forms.Textarea) 
```

2.修改blog/views.py中的blog_detail()方法

传递`context['comment_form']`值，并通过initial进行初始化值

```python
from comment.forms import CommentForm

def blog_detail(request,blog_pk):
    ...
    context['comment_form'] = CommentForm(initial={'content_type':blog_content_type.model, 'object_id':blog_pk}) 
    # 对forms表单中的类进行初始化定义值，initial对应的是一个list
    response = render(request, 'blog/blog_detail.html',context)  # 响应
    response.set_cookie(read_cookie_key, 'true')  # 阅读cookie标记

    return response

```

3.修改模板页面

使用`  {{ comment_form }}`使用传递过来的 comment_form

```django
<form action="{% url 'update_comment' %}" method="POST" style="overflow:hidden;">
  <label>{{ user.username }}，欢迎评论~</label>
  {% csrf_token %}
  {{ comment_form }}
  <input type="submit" value="评论" class="btn btn-primary" style="float:right">
</form>
```



### （2）修改验证comment的方法

因为blog有自己的编辑页面，所以这个页面会设计两个POST，所以建议不将校验过程写在views.py中

建议放在forms.py中

#### 1.在comment/forms.py中新建一个CommentForm的方法clean()

```python
class CommentForm(forms.Form):
    content_type = forms.CharField(widget=forms.HiddenInput) # HiddenInput在前端隐藏显示
    object_id = forms.IntegerField(widget=forms.HiddenInput)
    text = forms.CharField(widget=forms.Textarea)

    # 继承forms.Form进行实例化，在这个类中隐藏一个初始化的方法
    def __init__(self, *args, **kwargs):  # *args表示任意类型的参数；**kwargs表示任意关键字的参数
        if 'user' in kwargs: # 如果'user'在kwargs中做以下操作
            self.user = kwargs.pop('user') # pop()表示将'user'的内容从kwargs中拿出来剔除，放入self.user中，防止在super初始化时有参数报错
        super(CommentForm, self).__init__(*args, **kwargs) # 继承初始化的方法

    def clean(self):
        # 判断用户是否登录
        if self.user.is_authenticated:
            self.cleaned_data['user'] = self.user
        else:
            raise forms.ValidationError('用户尚未登录')
        #评论对象验证
        content_type = self.cleaned_data['content_type']
        object_id = self.cleaned_data['object_id']
        try:
            model_class = ContentType.objects.get(model=content_type).model_class()
            # 使用ContentType进行处理，根据'content_type'得到blog等对象类型,ContentType.objects.get获得一个外键关联的具体的blog对象
            # 使用model_class方法，可以得到具体的模型的class, 也就是得到Blog；使用model_class方法，可以根据一个具体的object对象，返回这个对象所属的class类
            model_obj = model_class.objects.get(pk=object_id)
            self.cleaned_data['content_object'] = model_obj
        except ObjectDoesNotExist:
            raise forms.ValidationError('评论不存在')
        return self.cleaned_data
```

#### 2.修改comment/views.py中的update_comment函数

使用python中的关键词传参数，传递user

并使用.is_valid()对POST中的内容进行验证

通过验证后将POST中的内容作为Comment类实例化保存，完成评论

未通过验证则报错

```python
def update_comment(request):
    referer = request.META.get('HTTP_REFERER', reverse('home'))
    comment_form = CommentForm(request.POST, user=request.user) # 进行实例化；使用python中的关键词传参数，传递user
    if comment_form.is_valid(): # 如果POST中的数据有效的话，就进行保存
        comment = Comment()
        comment.user = comment_form.cleaned_data['user']
        comment.text = comment_form.cleaned_data['text']
        comment.content_object = comment_form.cleaned_data['content_object']
        comment.save()
        return redirect(referer)
    else:
        return render(request, 'error.html', {'message':comment_form.errors, 'redirect_to':referer})
```



### （3）修改富文本编辑框

在GitHub中搜索[django-ckeditor](https://github.com/django-ckeditor/django-ckeditor)

并寻找包含form的内容：

[Widget](https://github.com/django-ckeditor/django-ckeditor#id8)

Alternatively, you can use the included `CKEditorWidget` as the widget for a formfield. For example:

```
from django import forms
from django.contrib import admin
from ckeditor.widgets import CKEditorWidget

from post.models import Post

class PostAdminForm(forms.ModelForm):
    content = forms.CharField(widget=CKEditorWidget())
    class Meta:
        model = Post
        fields = '__all__'

class PostAdmin(admin.ModelAdmin):
    form = PostAdminForm

admin.site.register(Post, PostAdmin)
```

![](https://gitee.com/gitten/PicBed/raw/master/20200809171628.png)

#### 使用widget使用富文本编辑器

（1）修改forms.py中text的widget

```python
from ckeditor.widgets import CKEditorWidget

class CommentForm(forms.Form):
    ...
    text = forms.CharField(widget=CKEditorWidget())
    ...
```

（2）在模板页面中引入需要用的js库

```django
{% block header_extends %}
    <link rel="stylesheet" type="text/css" href="{% static 'blog/blog.css' %}">
    <script type="text/javascript" src="{% static "ckeditor/ckeditor-init.js" %}"></script>
    <script type="text/javascript" src="{% static "ckeditor/ckeditor/ckeditor.js" %}"></script>
{% endblock %}
```

#### 配置CKeditor的背景

![image-20200809174832128](/Users/gitten/Library/Application Support/typora-user-images/image-20200809174832128.png)

配置widget

```
text = forms.CharField(widget=CKEditorWidget(config_name='comment_ckeditor'))
```

修改SETTINGS.py的中的`CKEDITOR_CONFIGS`

```
CKEDITOR_CONFIGS = {
    'comment_ckeditor': {
        'toolbar': 'custom',
        'toolbar_custom': [
            ['Bold', 'Italic', 'Underline', 'Strike', 'Subscript', 'Superscript'],
            ["TextColor", "BGColor", 'RemoveFormat'],
            ['NumberedList', 'BulletedList'],
            ['Link', 'Unlink'],
            ["Smiley", "SpecialChar", 'Blockquote'],
        ],
        'width': 'auto',
        'height': '180',
        'tabSpaces': 4, # tab键变为四个空格
        'removePlugins': 'elementspath',
        'resize_enabled': False,
    }
}
```

#### 去除页面上的text英文

```django 
<form action="{% url 'update_comment' %}" method="POST" style="overflow:hidden;">
  <label>{{ user.username }}，欢迎评论~</label>
  {% csrf_token %}
  {% for field in comment_form %}
  	{{ field }}
  {% endfor %} 
  <input type="submit" value="评论" class="btn btn-primary" style="float:right">
</form>
```

#### 使评论框占页面宽度100%

blog/static/blog.css

```css
div.django-ckeditor-widget {
    width:100%;
}
```

## （二）ajax提交

需要评论后页面不刷新，使用ajax异步请求

正常提交会刷新页面，可以ajax提交数据

ajax提交是一种不刷新页面的异步提交方式

### （1）修改模板页面，插入script代码，使用jQuery实现ajax提交

在模板页面最下面插入script代码，使用jQuery实现ajax提交

```django
{% block script_extends %}
    <script type="text/javascript">
        $("#comment_form").submit(function(){
            // 更新数据到textarea中
            CKEDITOR.instances['id_text'].updateElement();
            // 异步提交
            $.ajax({
                url: "{% url 'update_comment' %}",
                type: 'POST',
                data: $(this).serialize()  // $(this)表示使用当前方法中的对象，等同于$("#comment_form")；使用serialize()将这些对象序列化
                cache: false, // 将缓存关闭
                success: function(data){  // 执行成功后会执行法法
                    console.log(data);  // console.log() 方法用于在控制台输出信息。
                    if(data['status']=="SUCCESS"){
                        // 插入数据
                        var comment_html = '<div>' + data['username'] + 
                                                     ' (' + data['comment_time'] + '): ' + 
                                                     data['text'] + '</div>';
                        $("#comment_list").prepend('comment_html'); // 在comment_list的开头插入comment_html
                    }else{
                    }
                },
                error: function(xhr){
                    console.log(xhr);
                }
            })
            return false
        });
    </script>
{% endblock %}
```

### （2）修改update_comment路由函数

在form提交后，以JSON格式返回数据，用于更改页面

```python
def update_comment(request):
    referer = request.META.get('HTTP_REFERER', reverse('home'))
    comment_form = CommentForm(request.POST, user=request.user) # 进行实例化；使用python中的关键词传参数，传递user
    data = {}
    if comment_form.is_valid(): # 如果POST中的数据有效的话，就进行保存
        comment = Comment()
        comment.user = comment_form.cleaned_data['user']
        comment.text = comment_form.cleaned_data['text']
        comment.content_object = comment_form.cleaned_data['content_object']
        comment.save()

        # 返回数据
        data['status'] = 'SUCCESS '
        data['username'] = comment.user.username
        data['comment_time'] = comment.comment_time.strftime('%Y-%m-%d %H:%m:%S')
        data['text'] = comment.text
    else:
        data['status'] = 'SUCCESS '
        #return render(request, 'error.html', {'message':comment_form.errors, 'redirect_to':referer})
    return JsonResponse(data)
```

### （3）ERROR时的处理方法

在模板页面增加显示错误信息的<span>

```django
<span id="comment_error" class="text-danger pull-left"></span>
```

然后用js获取这个<span>的id，然后设置错误信息

```javascript
if(data['status']=="SUCCESS"){
  // 插入数据
  var comment_html = '<div>' + data['username'] + ' (' + data['comment_time'] + '): ' + data['text'] + '</div>';
  $("#comment_list").prepend('comment_html'); // 在comment_list的开头插入comment_html
  // 评论提交后自动清空评论框内的文字
  CKEDITOR.instances['id_text'].setData('') 
}else{
  // 显示错误信息
  $("#comment_error").text(data['message'])
}
```

修改update_comment()中的错误返回

```python
def update_comment(request):
    ...
    if comment_form.is_valid(): # 如果POST中的数据有效的话，就进行保存
    		...
    else:
        data['status'] = 'ERROR'
        # 取错误信息中的values，并将其转为list，并取第一个
        data['message'] = list(comment_form.errors.values())[0][0]
    return JsonResponse(data)
```

评论为空时，自定义报错内容，修改comment/forms.py中的CommentForm类中text属性的widget参数，为error_messages添加一个字典

```python
class CommentForm(forms.Form):
    ...
    text = forms.CharField(widget=CKEditorWidget(config_name='comment_ckeditor'),
                           error_messages={'required':'评论内容不能为空'})
```

为减轻服务器的负担，在前端对评论是否为空进行判断

```js
// 判断是否为空
$("#comment_error").text('');
if(CKEDITOR.instances['id_text'].document.getBody().getText().trim()==''){
    // 显示错误信息
    $("#comment_error").text('评论内容不能为空');
}
```

## （三）更正

### 几个小细节

1. 时间格式修饰器前面写错了

   `({{ comment.comment_time|date:"Y-m-d H:n:s" }})`  -->  `({{ comment.comment_time|date:"Y-m-d H:i:s" }})`

2. 富文本内容的html标签未在下方comment_list中转义

   `{{ comment.text|safe }} `  使评论内容中的html内容转义

3. 在settings.py中更改时区

4. 提交评论后自动清空评论框内的文字

   ```django
   CKEDITOR.instances['id_text'].setData('') // 评论提交后自动清空评论框内的文字
   ```



# 二十六、回复功能设计和树结构

## （一）如何设计回复功能

- 评论可被回复
- 回复可被回复

### 通过`related_name`将Comment与自己关联

修改comment/models.py

```python
root = models.ForeignKey('self', related_name="root_comment", null=True, on_delete=models.DO_NOTHING) # 这条回复的最顶级评论是什么
parent = models.ForeignKey('self', related_name="parent_commment", null=True, on_delete=models.DO_NOTHING) # 与自己形成外键关联，构成树结构
reply_to = models.ForeignKey(User, related_name="replies", null=True, on_delete=models.DO_NOTHING)
```

通过`ForeignKey('self',)`与自己关联，构建`root`和`parent`

- `root` 表示这个评论的树结构最顶级是那一条评论
- `parent ` 表示这个评论的树结构父级评论
- `reply_to` 表示向哪个用户回复
- 因为`reply_to`和`user`都外键关联的都是User，为了区分，可以分别设置`related_name`

```python
class Comment(models.Model):
    content_type = models.ForeignKey(ContentType, on_delete=models.DO_NOTHING)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey('content_type', 'object_id') 
    # content_object表示指向另一个model中的class的一个具体object

    text = models.TextField()
    comment_time = models.DateTimeField(auto_now_add=True)
    user = models.ForeignKey(User, related_name="comments", on_delete=models.DO_NOTHING) # related_name表示反向解析的名字

    root = models.ForeignKey('self', related_name="root_comment", null=True, on_delete=models.DO_NOTHING) # 这条回复的最顶级评论是什么
    parent = models.ForeignKey('self', related_name="parent_commment", null=True, on_delete=models.DO_NOTHING) # 与自己形成外键关联，构成树结构
    reply_to = models.ForeignKey(User, related_name="replies", null=True, on_delete=models.DO_NOTHING)

    def __str__(self):
        return self.text   # 使admin中新增时能看到回复对象的内容

    class Meta:
        ordering = ['comment_time']
```

使用`__str__()`方法使在调用这个类的具体时，返回评论的具体内容

```python
def __str__(self):
		return self.text   # 使admin中新增时能看到回复对象的内容
```

### 修改blog/views.py中的blog_detail()函数

给comments增加一个参数`parent=None`,表示只传递一级评论内容

```python
def blog_detail(request,blog_pk):
    ...
    comments = Comment.objects.filter(content_type=blog_content_type, object_id=blog.pk, parent=None) 
    # parent=None表示只显示一级评论
```





### 修改模板，在一级评论下方显示2、3..级评论

修改blog_detail.html

```html
{% for comment in comments %}
  <div id="root_{{ comment.pk }}" class="comment">
    <span>{{ comment.user.username }}</span>
    <span>({{ comment.comment_time|date:"Y-m-d H:i:s" }}):</span>
    <div id="comment_{{ comment.pk }}">
      {{ comment.text|safe }}   {# 使评论内容中的html内容转义 #}
    </div>
    <a href="javascript:reply({{ comment.pk }})">回复</a>

    {% for reply in comment.root_comment.all %}
    <div class="reply">
      <span>{{ reply.user.username }}</span>
      <span>({{ reply.comment_time|date:"Y-m-d H:i:s" }}):</span>
      <span>回复</span>
      <span>{{ reply.reply_to.username }}</span>
      <div id="comment_{{ reply.pk }}">
        {{ reply.text|safe }}   {# 使评论内容中的html内容转义 #}
      </div>
      <a href="javascript:reply({{ reply.pk }})">回复</a>
    </div>
    {% endfor %}
  </div>
{% empty %}
```

使用反向处理方法，也就是上面models.py类中各属性的`related_name="root_comment"`

在模板中`comment`循环中，嵌套一个`reply`循环

```html
{% for reply in comment.root_comment.all %}
    <div class="reply">
      <span>{{ reply.user.username }}</span>
      <span>({{ reply.comment_time|date:"Y-m-d H:i:s" }}):</span>
      <span>回复</span>
      <span>{{ reply.reply_to.username }}</span>
      <div id="comment_{{ reply.pk }}">
        {{ reply.text|safe }}   {# 使评论内容中的html内容转义 #}
      </div>
      <a href="javascript:reply({{ reply.pk }})">回复</a>
    </div>
{% endfor %}
```

`{% for reply in comment.root_comment.all %}`中的`comment.root_comment.all`表示comment反向关联的所有评论他的回复，也就是所有评论过他的评论，然后通过for循环遍历出来，再将reply的用户名、评论时间、评论对象、评论内容显示出来

### 修改css调整前端显示

```css
div.comment {
    border-bottom: 1px dashed #ccc;
    margin-bottom: 0.5em;
    padding-bottom: 0.5em;
}
div.reply {
    margin-left: 2em;
}
```

## （二）在评论中添加"回复"按钮

### 修改comment/forms.py，新增reply_comment_id

添加属性`reply_comment_id`，他表示要回复的对象id

```python
class CommentForm(forms.Form):
    ...
    reply_comment_id = forms.IntegerField(widget=forms.HiddenInput(attrs={'id':'reply_comment_id'})) # 隐藏字段，但是能传入一个id
	...
```

### 修改blog/views.py

在初始化时，默认`reply_comment_id`的值为0，初始化的目的是方便前端进行调用

```python
def blog_detail(request,blog_pk):
    ...
    context['comment_form'] = CommentForm(initial={'content_type':blog_content_type.model, 'object_id':blog_pk, 'reply_comment_id': 0}) 
    # 对forms表单中的类进行初始化定义值，方便前端代码调用，initial对应的是一个list; blog_content_type是一个对象，blog_content_type.model是这个对象名称字符串
    ...
    return response
```

### 在前端模板页面添加“回复”按钮，并赋予JavaScript函数操作，实现回复评论并回滚页面

#### 1.回复按钮

`<a href="javascript:reply({{ reply.pk }})">回复</a>`表示点击`回复`后激活JavaScript函数reply，并向其传递这条评论的id

#### 2.JavaScript代码 - 点击某条评论下的回复，修改富文本编辑器`reply_comment_id`的值，将其修改为评论对象的id

```javascript
function reply(reply_comment_id){
    // 设置值
    $('#reply_comment_id').val(reply_comment_id);  // var表示改变选取元素id=reply_comment_id的input中的value值
}
```

上述forms和views传递过来的表及评论编辑器form中的`'id':'reply_comment_id'`，在前端显示为`<input>`中的一个参数

comment/forms.py中`reply_comment_id = forms.IntegerField(widget=forms.HiddenInput(attrs={'id':'reply_comment_id'}))`

➡️ 在前端显示为`<input type="hidden" name="reply_comment_id" value="0" id="reply_comment_id">`

> $('#reply_comment_id').var()表示改变选取元素id=reply_comment_id的input中的value值

#### 3.JavaScript代码 - 点击回复后回滚至富文本编辑器处

```javascript
function reply(reply_comment_id){
   ...
    // 回滚至回复框
    $('html').animate({scrollTop: $('#comment_form').offset().top - 60}, 300, function(){
        CKEDITOR.instances['id_text'].focus();
    });
}
```

#### 4.修改回复评论时富文本编辑器顶部，增加回复对象的内容

在ckeditor编辑器上方增加`<div id="reply_content_container" style="display: none;">`，在页面一开始这块内容是不显示的

```html
<div id="reply_content_container" style="display: none;">
    <p>回复：</p>
    <div id="reply_content"></div>
</div>
```

为每一个评论、评论回复设置一个id

```html
<div id="comment_{{ comment.pk }}">
    {{ comment.text|safe }}   {# 使评论内容中的html内容转义 #}
</div>
...
    <div id="comment_{{ reply.pk }}">
        {{ reply.text|safe }}   {# 使评论内容中的html内容转义 #}
    </div>
```

通过js代码

`var html = $("#comment_" + reply_comment_id).html();`取到每个评论、评论回复下的HTML代码，并将其赋值给html

再通过`$('#reply_content').html(html);`修改`<div id="reply_content">`中的内容

并通过`$('#reply_content_container').show();`让`<div id="reply_content_container">`显示出来

```javascript
function reply(reply_comment_id){
    // 设置值
    $('#reply_comment_id').val(reply_comment_id);  // var表示改变选取元素id=reply_comment_id的input中的value值
    var html = $("#comment_" + reply_comment_id).html();
    $('#reply_content').html(html);
    $('#reply_content_container').show();
    ...
};
```

#### 5.在回复评论完成后，隐藏富文本编辑器顶部的头

在之前的ajax请求js代码中，增加将`$('#reply_content_container').hide();`的操作

并在提交评论后，将“暂无评论”几个字去除 `$('#no_comment').remove();`

```javascript
// 评论提交后自动清空评论框内的文字
CKEDITOR.instances['id_text'].setData(''); 
$('#reply_content_container').hide();
$('#reply_comment_id').val('0');  // 将回复平对的对象id重置为0
$('#no_comment').remove();
```



### 对CommentForm中新增的reply_comment_id进行校验

在comment/forms.py中CommentForm中添加一个clean_reply_comment_id方法

```python
def clean_reply_comment_id(self):
    reply_comment_id = self.cleaned_data['reply_comment_id']
    if reply_comment_id < 0:
        raise forms.ValidationError('回复出错')
    elif reply_comment_id == 0:
        self.cleaned_data['parent'] = None
    elif Comment.objects.filter(pk=reply_comment_id).exists():
        self.cleaned_data['parent'] = Comment.objects.get(pk=reply_comment_id)
    else:
        raise forms.ValidationError('回复出错')
    return reply_comment_id
```

### 判断是评论，还是回复评论：修改comment/views.py中的update_comment()路由函数

```python
def update_comment(request):
    ...
        parent = comment_form.cleaned_data['parent']
        if not parent is None:
            comment.root = parent.root if not parent.root is None else parent
            comment.parent = parent
            comment.reply_to = parent.user
        comment.save()
        
        # 返回数据
        data['status'] = 'SUCCESS'
        data['username'] = comment.user.username
        data['comment_time'] = comment.comment_time.strftime('%Y-%m-%d %H:%m:%S')
        data['text'] = comment.text
        if not parent is None:
            data['reply_to'] = comment.reply_to.username   
        else:
            data['reply_to'] = ''
        data['pk'] = comment.pk 
        data['root_pk'] = comment.root.pk if not comment.root is None else ''
```

### 前端模板页面JavaScript判断是评论还是回复评论：

拼接字符串，并将结果插入到原有的HTML内容中

```javascript
if($('#reply_comment_id').val()=='0'){
    // 插入评论
    var comment_html = '<div id="root_' + data['pk'] + '" class="comment"><span>' + data['username'] + '</span><span>(' + data['comment_time'] + ')</span><div id="comment_' + data['pk'] + '">' + data['text'] + '</div><a href="javascript:reply(' + data['pk'] + ')">回复</a></div>';
    $("#comment_list").prepend(comment_html);// 在comment_list的开头插入comment_html
}else{
    // 插入回复
    var reply_html = '<div class="reply"><span>' + data['username'] + '</span><span>(' + data['comment_time'] + '):</span><span>回复</span><span>(' + data['reply_to'] + ')</span><div id="comment_' + data['pk'] + '">' + data['text'] + '</div><a href="javascript:reply(' + data['pk'] + ')">回复</a></div>';
    $("#root_" + data['root_pk']).append(reply_html);
}
// 评论提交后自动清空评论框内的文字
CKEDITOR.instances['id_text'].setData(''); 
$('#reply_content_container').hide();
$('#reply_comment_id').val('0');
$('#no_comment').remove();
```

# 二十七、获取评论数和细节处理

## （一）如何获取评论数

### 方法一：filter筛选再用count方法技术

问题：页面和代码复杂了

#### 修改blog/views.py/blog_detail()，传递`comment_count`参数

`context['comment_count'] = Comment.objects.filter(content_type=blog_content_type, object_id=blog.pk).count()`

#### 在前端模板页面blog_detail.html中接受`comment_count`参数

`<li>评论({{ comment_count }})</li>`

此时完成了具体页面中的评论计数，但是在博客列表中，使用原来阅读计数的方法，会导致代码变得十分复杂，所以选择使用另一种方法——自定义模板标签

## （二）自定义模板标签

降低耦合，代码更加独立和使用更加简单

### 在app内创建templatetags包

新建templatetags文件夹，并在文件夹内新建`__init__.py`文件

### 创建py文件

在templatetags文件夹内创建comment_tags.py文件

### 注册模板标签函数

```python
from django import template


# 用于注册
register = template.Library()

# 注册为简单的模板标签
@register.simple_tag
def test(a):
    return 'this is test code' + a
```

### load标签加载该文件

在前端模板页面加载刚刚在templatetags文件夹内创建comment_tags.py文件

`{% load comment_tags %}`

> 这里load后面的comment_tags表示在templatetags文件夹内创建comment_tags.py文件的名字

### 在前端模板页面向标签函数传递参数

`<li>{% test 'string' %}</li>`

其中test为函数名，用空格间隔开，空格后面为传递的参数



## （三）修改评论数显示方法

### 注册标签函数

comment/templatetags/comment_tags.py:

```python
from django import template
from django.contrib.contenttypes.models import ContentType
from ..models import Comment

# 用于注册
register = template.Library()

# 注册为简单的模板标签
@register.simple_tag
def get_comment_count(obj):
    content_type = ContentType.objects.get_for_model(obj)
    return Comment.objects.filter(content_type=content_type, object_id=obj.pk).count()
    
```

### 前端模板页面加载标签函数，并传递参数

```html
{% load comment_tags %}

<li>评论({% get_comment_count blog %})</li>
```

> Django官网文档搜索tag，custom template tags and filters中有详细描述标签函数



## （四）优化评论，用标签函数传递

### 用模板标签函数来传递`comments`和`comment_form`

comment/templatetags/comment_tags.py:

```python
@register.simple_tag    
def get_comment_form(obj):
    content_type = ContentType.objects.get_for_model(obj)
    form = CommentForm(initial={
        'content_type':content_type.model, 
        'object_id':obj.pk, 
        'reply_comment_id': 0}) 
    # 对forms表单中的类进行初始化定义值，方便前端代码调用，initial对应的是一个list; blog_content_type是一个对象，blog_content_type.model是这个对象名称字符串
    return form

@register.simple_tag
def get_comment_list(obj):
    content_type = ContentType.objects.get_for_model(obj)
    comments = Comment.objects.filter(content_type=content_type, object_id=obj.pk, parent=None) # parent=None表示只显示一级评论
    return comments.order_by('-comment_time')
```

### 前端模板页面加载标签函数，并传递参数

```
{# 传递comment_form #}
{% get_comment_form blog as comment_form %}
{% for field in comment_form %}
	{{ field }}
{% endfor %} 

{# 传递comments #}
{% get_comment_list blog as comments %}
{% for comment in comments%}
    <div id="root_{{ comment.pk }}" class="comment">
    	<span>{{ comment.user.username }}</span>
        <span>({{ comment.comment_time|date:"Y-m-d H:i:s" }}):</span>
        <div id="comment_{{ comment.pk }}">
            {{ comment.text|safe }}   {# 使评论内容中的html内容转义 #}
        </div>
    	<a href="javascript:reply({{ comment.pk }})">回复</a>


        {% for reply in comment.root_comment.all %}
        <div class="reply">
            <span>{{ reply.user.username }}</span>
            <span>({{ reply.comment_time|date:"Y-m-d H:i:s" }}):</span>
            <span>回复</span>
            <span>{{ reply.reply_to.username }}</span>
            <div id="comment_{{ reply.pk }}">
            	{{ reply.text|safe }}   {# 使评论内容中的html内容转义 #}
            </div>
            <a href="javascript:reply({{ reply.pk }})">回复</a>
        </div>
        {% endfor %}
    </div>
{% empty %}
	<span id="no_comment">暂无评论</span>
{% endfor %}

```



## （五）细节处理

### ajax返回的日期

问题：评论后ajax提交，评论列表中刷新的时间与时间时间不同

方法：使用timestamp()，使返回的时间变成时间戳，指距离格林威治时间1970年1月1日0时0分0秒的秒数

comment/views.py/update_comment():

 `data['comment_time'] = comment.comment_time.timestamp()`

前端模板页面通过js将时间戳显示为统一格式的时间

```javascript
function numFormat(num){
    return ('00' + num).substr(-2);    // 返回的数字前面加00，再取后两位，这样个位数的话前面会加0
}
function timeFormat(timestamp){
    var datetime = new Date(timestamp * 1000);
    var year = datetime.getFullYear();
    var month = numFormat(datetime.getMonth() + 1);
    var day = numFormat(datetime.getDate());
    var hour = numFormat(datetime.getHours());
    var minute = numFormat(datetime.getMinutes());
    var second = numFormat(datetime.getSeconds());
    return year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second;
}
```

### CSS样式调整

```css
div#reply_content_container {
    border: 1px solid #d1d1d1;
    border-bottom: none;
    background-color: #f8f8f8;
    overflow: hidden;
    padding: 1em 1em 0.5em;
}
p#reply_title {
    border-bottom: 1px dashed #ccc;
    padding-bottom: 0.5em;
}
```

### 级联删除

django文档搜索foreignKey

将所有`on_delete=models.DO_NOTHING`替换为`on_delete=models.CASCADE`

DO_NOTHING 表示什么都不做

CASCADE 表示级联删除，则会将级联关联的同时删除，例如删除某个评论时，该评论下的回复也会被删除

### Django-ckeditor

在为评论时的ckeditor自定义样式后，后台使用ckeditor会报错

方法：在settings.py中增加default样式

```python
CKEDITOR_CONFIGS = {
    'default': {},
    'comment_ckeditor': {
        'toolbar': 'custom',
        'toolbar_custom': [
            ['Bold', 'Italic', 'Underline', 'Strike', 'Subscript', 'Superscript'],
            ["TextColor", "BGColor", 'RemoveFormat'],
            ['NumberedList', 'BulletedList'],
            ['Link', 'Unlink'],
            ["Smiley", "SpecialChar", 'Blockquote'],
        ],
        'width': 'auto',
        'height': '180',
        'tabSpaces': 4, # tab键变为四个空格
        'removePlugins': 'elementspath',
        'resize_enabled': False,
    }
}
```





# 二十八、用所学知识实现点赞功能

## （一）点赞功能设计

1. 博客和评论、回复可点赞
2. 可取消点赞
3. 可看到点赞数



## （二）实现LIke点赞功能

### 新建app

```
$ python manage.py startapp likes
```

### 创建模型

创建模型LikeCount、LikeRecord

```python
from django.db import models
from django.contrib.contenttypes.fields import GenericForeignKey
from django.contrib.contenttypes.fields import ContentType
from django.contrib.auth.models import User

class LikeCount(models.Model):
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey('content_type', 'object_id')

    liked_num = models.IntegerField(default=0)

class LikeRecord(models.Model):
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey('content_type', 'object_id')

    user = models.ForeignKey(User, on_delete=models.CASCADE)
    liked_time = models.DateTimeField(auto_now_add=True)
```

### 在前端模板页面增加点赞按钮

```html
<div class="like" onclick="likeChange(this, '{% get_content_type blog %}', {{ blog.pk }})">    
    <span class="glyphicon glyphicon-thumbs-up {% get_like_status blog  %}"></span>
    <span class="liked-num">{% get_like_count blog %}</span>
    <span>喜欢</span>
</div>  
```

点击这个按钮时，会运行likeChange这个JavaScript函数，并将自己、blog所属class类型、blog.pk传递过去

`{% get_content_type blog %}` 是通过使用模板标签函数来传递blog的类型

`<span class="glyphicon glyphicon-thumbs-up {% get_like_status blog  %}"></span>`中class的前两个参数是bootstrap中的内置样式，而后面的`{% get_like_status blog  %}`则是将这个span是否为active传递过来，用以实现点击后高亮，再点击后取消高亮

### 添加CCS

```css
div.like {
    color: #337ab7;
    cursor: pointer;
    display: inline-block;
    padding: 0.5em 0.3em;
}
div.like .active {
    color: #f22;
}
```

### 添加JavaScript点击函数

```javascript
function likeChange(obj, content_type, object_id){
    var is_not_like = obj.getElementsByClassName('active').length == 0
    $.ajax({
        url: "{% url 'like_change' %}",
        type: 'GET',  // Django在前端js中使用POST时需要一个csrf_token，如果前端没有使用Django的form，则没有这个认证，无法使用POST
        data: {
            content_type: content_type,
            object_id: object_id,
            is_not_like: is_not_like
        },
        cache: false,
        success: function(data){
            console.log(data)
            if(data['status']=='SUCCESS'){
                // 更新点赞状态
                var element = $(obj.getElementsByClassName('glyphicon'));
                if(is_not_like){
                    element.addClass('active');
                }else{
                    element.removeClass('active');
                }
                // 更新点赞数量
                var liked_num = $(obj.getElementsByClassName('liked-num'));
                liked_num.text(data['liked_num']); // 设置文本信息
            }else{
                alert(data['message']);
            }
        },
        error: function(xhr){
            console.log(xhr)
        }
    })
}
```

Django在前端js中使用POST时需要一个csrf_token，如果前端没有使用Django的form，则没有这个认证，无法使用POST

### 设置点赞的url路由

在mysite/urls.py中添加`path('likes/', include('likes.urls')),`

在likes文件夹中新建urls.py文件：

```python
from django.urls import path
from . import views

urlpatterns = [
    path('like_change', views.like_change, name='like_change'),    
]
```

### 新建点赞的views.py路由函数

```python
from django.shortcuts import render
from django.contrib.contenttypes.models import ContentType
from django.http import JsonResponse
from django.db.models import ObjectDoesNotExist
from .models import LikeCount, LikeRecord

def SuccessResponse(liked_num):
    data = {}
    data['status'] = 'SUCCESS'
    data['liked_num'] = liked_num
    return JsonResponse(data)

def ErrorResponse(code, message):
    data = {}
    data['status'] = 'ERROR'
    data['code'] = code
    data['message'] = message
    return JsonResponse(data)


def like_change(request):
    # 获取数据
    user = request.user
    if not user.is_authenticated:                   # 判断是否登录
        return ErrorResponse(400, 'you were not login')

    content_type = request.GET.get('content_type')  # 根据前端ajax传递过来的数据赋值，前段传递过来的是一个文本
    object_id = int(request.GET.get('object_id'))

    try:                                            # 通过这一段try来判断前段传递过来的models类型是否存在
        content_type = ContentType.objects.get(model=content_type) # 如果传递过来的是blog类型，获取<ContentType: blog>
        model_class = content_type.model_class()                   # 如果传递过来的是blog类型，获取blog的class：<class 'blog.models.Blog'>
        model_obj = model_class.objects.get(pk=object_id)          # 如果传递过来的是blog类型，获取pk所对应的具体blog：<Blog: Blog: for 30>
    except ObjectDoesNotExist:
        return ErrorResponse(401, 'object not exist')

    # 处理数据
    if request.GET.get('is_not_like') == 'true':
        # 要点赞
        like_record, created = LikeRecord.objects.get_or_create(content_type=content_type, object_id=object_id, user=user)
        if created: # 如果是新建的
            # 未点赞过，进行点赞
            like_count, created = LikeCount.objects.get_or_create(content_type=content_type, object_id=object_id)
            like_count.liked_num += 1
            like_count.save()
            return SuccessResponse(like_count.liked_num)
        else:
            # 已点赞过，不能重复点赞
            return ErrorResponse(402, 'you were liked')
    else:
        # 要取消点赞
        if LikeRecord.objects.filter(content_type=content_type, object_id=object_id, user=user).exists():
            # 有点赞过，取消点赞
            like_record = LikeRecord.objects.filter(content_type=content_type, object_id=object_id, user=user)
            like_record.delete()
            # 点赞总数减一
            like_count, created = LikeCount.objects.get_or_create(content_type=content_type, object_id=object_id)
            if not created:
                like_count.liked_num -= 1
                like_count.save()
                return SuccessResponse(like_count.liked_num)
            else:
                return ErrorResponse(404, 'data error')
        else:
            # 没有点赞过，不能取消
            return ErrorResponse(403, 'you were not liked')
```

### 设置点赞的模板标签函数，显示点赞数、

```python
from django import template
from django.contrib.contenttypes.models import ContentType
from ..models import LikeCount, LikeRecord

# 用于注册
register = template.Library()

# 注册为简单的模板标签
@register.simple_tag
def get_like_count(obj):
    content_type = ContentType.objects.get_for_model(obj)
    like_clount, created = LikeCount.objects.get_or_create(content_type=content_type, object_id=obj.pk)
    return like_clount.liked_num

@register.simple_tag(takes_context=True) # takes_context=True表示可以使用所在模板的模板变量
def get_like_status(context, obj):
    content_type = ContentType.objects.get_for_model(obj)
    user = context['user']
    if not user.is_authenticated:
        return ''
    if LikeRecord.objects.filter(content_type=content_type, object_id=obj.pk, user=user).exists():
        return 'active'
    else:
        return ''

@register.simple_tag
def get_content_type(obj):
    content_type = ContentType.objects.get_for_model(obj)
    return content_type.model
```

## （三）前后端开发建议：

功能需求分析 -> 模型设计 -> 前端初步开发 -> 后端实现 -> 完善前端代码

## （四）运用到所学知识点

Django基础（models、views、urls、……）

ContentType

ajax

自定义模板标签





# 二十九、完善点赞功能

## （一）完善功能

1. 新增评论和恢复无法点赞
2. 未登录请胯下点赞



## （二）新增评论和回复的点赞功能

新增评论和回复没有onclick事件

字符串拼接问题

### 在js中创建format方法，来替换html中'{}'中的内容

```js
String.prototype.format = function(){    // 创建format方法，来替换html中'{}'中的内容
    var str = this;
    for (var i =0; i < arguments.length; i++) {  // arguments表示所有参数的一个集合
        var str = str.replace(new RegExp('\\{' + i + '\\}', 'g'), arguments[i])  // this代表这个字符串,如果format(a,b,c)的话，这里arguments[i]可以获得a,b,c这些值
        };
    return str;
}
```

可以将这些代码复制到Chrome中的F12的Console中去验证

### 简化js代码

```js
if($('#reply_comment_id').val()=='0'){
    // 插入评论
    var comment_html = 
        '<div id="root_{0}" class="comment">' +
        '<span>{1}</span>' +
        '<span>({2}):</span>' +
        '<div id="comment_{0}">{3}</div>' +
        '<div class="like" onclick="likeChange(this, \'{4}\', {0})">' +
        '<span class="glyphicon glyphicon-thumbs-up"></span> ' +
        '<span class="liked-num">0</span>' +
        '</div>' +
        '<a href="javascript:reply({0});">回复</a>' +
        '</div>';
    comment_html = comment_html.format(data['pk'], data['username'], timeFormat(data['comment_time']), data['text'], data['content_type']);

    $("#comment_list").prepend(comment_html);// 在comment_list的开头插入comment_html
}else{
    // 插入回复
    var reply_html = 
        '<div class="reply">' +
        '<span>{1}</span>' +
        '<span>({2}):</span>' +
        '<span>回复</span>' +
        '<span>{3}</span>' +
        '<div id="comment_{0}">{4}</div>' +
        '<div class="like" onclick="likeChange(this, \'{5}\', {0})">' +
        '<span class="glyphicon glyphicon-thumbs-up"></span> ' +
        '<span class="liked-num">0</span>' +
        '</div>' +
        '<a href="javascript:reply({0});">回复</a>' +
        '</div>';
    reply_html = reply_html.format(data['pk'], data['username'], timeFormat(data['comment_time']), data['reply_to'], data['text'], data['content_type']);
    $("#root_" + data['root_pk']).append(reply_html);
}
```

## （三）未登录时点赞，跳出登录框

### 在前端模板页面，调用bootstrap中的模态框

```html
<!-- Modal -->
<div class="modal fade" id="login_modal" tabindex="-1" role="dialog">
    <div class="modal-dialog modal-sm" role="document">
        <div class="modal-content">
            <form id="login_modal_form" action="" method="POST">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
                    <h4 class="modal-title">登录</h4>
                </div>
                <div class="modal-body">
                    {% csrf_token %}
                    {% for field in login_form %}
                    <label for='{{ field.id_for_label }}'>{{ field.label }}</label>
                    {{ field }}
                    {% endfor %}
                    <span id="login_modal_tip" class="text-danger"></span>
                </div>
                <div class="modal-footer">
                    <button type="submit" class="btn btn-primary">登录</button>
                    <button type="button" class="btn btn-default" data-dismiss="modal">关闭</button>
                </div>
            </form>
        </div>
    </div>
</div>
```

### 并使用ajax提交，增加js代码

```js
$("#login_modal_form").submit(function(event){
    event.preventDefault();  // 阻止原本的事件生效
    $.ajax({
        url: '{% url "login_for_modal" %}',
        type: 'POST',
        data: $(this).serialize(),
        cache: false,
        success: function(data){
            if(data['status']=='SUCCESS'){
                window.location.reload();  // 当前窗口进行重新加载
            }else{
                $('#login_modal_tip').text('用户名或密码不正确');
            }
        }
    });
});
```

### 设置专门用于模态框登录的路由和路由函数

mysite/views.py:

```python
def login_for_modal(request):
    login_form = LoginForm(request.POST)
    data = {}
    if login_form.is_valid():  
        user = login_form.cleaned_data['user']
        auth.login(request, user)  
        data['status'] = 'SUCCESS'
    else:
        data['status'] = 'ERROR'
    return JsonResponse(data)
```

mysite/urls.py:

```python
urlpatterns = [
    ...
    path('login_for_modal/', views.login_for_modal, name='login_for_modal'),
```





# 三十、导航栏添加用户操作

## （一）方便登录登出

引用bootstrap中的导航栏样式，在导航栏右侧添加“登录/注册”或用户信息按钮

```html
<ul class="nav navbar-nav navbar-right">
    {% if not user.is_authenticated %}
    {# <li><a href="{% url 'login' %}?from={{ request.get_full_path }}">登录</a></li> #}
    <li><a href="javascript:$('#login_modal').modal('show');">登录</a></li>
    <li><a href="{% url 'register' %}?from={{ request.get_full_path }}">注册</a></li>
    {% else %}
    <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button">{{ user.username }} <span class="caret"></span></a>
        <ul class="dropdown-menu">
            <li><a href="{% url 'user_info' %}">个人资料</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="{% url 'logout' %}?from={{ request.get_full_path }}">登出</a></li>
        </ul>
    </li>
    {% endif %}
</ul>
```

## （二）手动创建模型

1. 手动在mysite文件夹下新建user文件夹
2. 在user文件夹内新建migrations文件夹
3. 将`__init__.py`文件复制到到user、user/migrations两个文件夹中
4. 将之前在其他views.py、urls.py、forms.py中的内容复制到user文件夹下

## （三）实现全局引用LoginForm

参照settings.py中全局引用auth的类型

```python
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [
            os.path.join(BASE_DIR, 'templates'),    #定义全局模板文件夹路径
        ],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',  # 参照这个来设置
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
```

在user文件夹下新建`context_processors.py`文件:

```python
from .forms import LoginForm

def login_modal_form(request):
    return {'login_modal_form': LoginForm()}
```

并在settings.py中TEMPLATES.OPTIONS.context_processors中增加`'user.context_processors.login_modal_form',`

然后将于LoginForm有关的前端HTML+JS迁移至base.html中

## （四）将所有app归总到同一个文件夹下（不建议）

在mysite下新建文件夹apps，将已有的所有app文件夹移到这个文件夹内

再修改settings.py文件

```python
import sys

sys.path.insert(0, os.path.join(BASE_DIR, 'apps'))
```



# 三十一、自定义用户模型

## （一）拓展方法

1. 继承Django的用户模型
2. 新的模型拓展关联User

## （二）继承Django用户模型

### 方法：

#### 1.自定义模型继承AbstractUser

#### 2.配置settings.py的AUTH_USER_MODEL

### 使用：

#### 外键关联settings.AUTH_USER_MODEL

#### 用get_user_model的方法获取User模型

### 优缺点

#### 优点

1. 自定义强
2. 没有不必要的字段（需要继承AbstractUser）

#### 缺点

1. 需要删库重来或是要项目一开始就使用
2. 配置admin麻烦

## （三）新的模型拓展关联User

### 方法：

#### 1.创建自定义模型

在user/下新建models.py文件

```python
from django.db import models 
from django.contrib.auth.models import User


class Profile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE, verbose_name='昵称')
    nickname = models.CharField(max_length=20)

    def __str__(self):
        return '<Profile: %s for %s>' % (self.nickname, self.user.username)
```

#### 2.外键关联User

同时创建admin.py在后台显示内容

```python
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from django.contrib.auth.models import User
from .models import Profile


class ProfileInline(admin.StackedInline):
    model = Profile
    can_delete = False

class UserAdmin(BaseUserAdmin):
    inlines = (ProfileInline, )
    list_display = ('username', 'nickname', 'email', 'is_staff', 'is_active', 'is_superuser')

    def nickname(self, obj):
        return obj.profile.nickname
    nickname.short_description = '昵称'

# Re-register UserAdmin
admin.site.unregister(User)
admin.site.register(User, UserAdmin)

@admin.register(Profile)
class ProfileAdmin(admin.ModelAdmin):
    list_display = ('user', 'nickname')
```

### 使用：

直接使用即可

### 优缺点

#### 优点

1. 使用方便
2. 不用删库重来影响整体构架

#### 缺点

1. 存在不必要的字段
2. 对比继承的方法，查询速度稍稍慢一丁点









# 三十二、修改用户信息

## （一）修改用户信息

1. 昵称
2. 邮箱
3. 密码

## （二）修改昵称

注意：

user不定有对应的Profile（未创建）

昵称不能为空（Form表单判断）

### （1）在user/forms.py中新建ChangeNicknameForm

```python
class ChangeNicknameForm(forms.Form):
    nickname_new = forms.CharField(      # 创建一个新的form
        label='新的昵称', 
        max_length=20,
        widget=forms.TextInput(
            attrs={'class':'form-control', 'placeholder':'请输入新的昵称'}
        )
    )
    # 继承forms.Form进行实例化，在这个类中隐藏一个初始化的方法
    def __init__(self, *args, **kwargs):  # *args表示任意类型的参数；**kwargs表示任意关键字的参数
        if 'user' in kwargs: # 如果'user'在kwargs中, 做以下操作
            self.user = kwargs.pop('user') # pop()表示将'user'的内容从kwargs中拿出来剔除，放入self.user中，防止在super初始化时有参数报错
        super(ChangeNicknameForm, self).__init__(*args, **kwargs) # 继承初始化的方法

    def clean(self):
        # 判断用户是否登录
        if self.user.is_authenticated:
            self.cleaned_data['user'] = self.user
        else:
            raise forms.ValidationError('用户尚未登录')
        return self.cleaned_data

    def clean_nickname_new(self):
        nickname_new = self.cleaned_data.get('nickname_new', '').strip()
        if nickname_new == '':
            raise ValidationError("新的昵称不能为空")
        return nickname_new
```

### （2）在user/views.py中新建路由函数change_nickname

```python
from .models import Profile

def change_nickname(request):
    redirect_to = request.GET.get('from', reverse('home'))
    if request.method == 'POST':
        form = ChangeNicknameForm(request.POST, user=request.user)
        if form.is_valid():
            nicknaem_new = form.cleaned_data['nickname_new']
            profile, created = Profile.objects.get_or_create(user=request.user)
            profile.nickname = nicknaem_new
            profile.save()
            return redirect(redirect_to)
    else:
        form = ChangeNicknameForm()

    context = {}
    context['form'] = form
    context['page_title'] = '修改昵称'
    context['form_title'] = '修改昵称'
    context['submit_title'] = '修改'
    context['return_back_url'] = redirect_to
    return render(request, 'form.html', context)
```

### （3）在user/urls.py中添加路由

```python
urlpatterns = [
    ...
    path('change_nickname/', views.change_nickname, name='change_nickname'),
]
```

### （4）新建form.html模板页面

```django
{% extends 'base.html' %}
{% load staticfiles %}
{# 页面标题 #}
{% block title %}
    {{ page_title }}
{% endblock %}
{% block nav_home_active %}active{% endblock %}
{% block content %}
    <div class="container">
        <div class="row">
            <div class="col-xs-4 col-xs-offset-4">
                <div class="panel panel-default">
                    <div class="panel-heading">
                    <h3 class="panel-title">{{ form_title }}</h3>
                    </div>
                    <div class="panel-body">
                    <form action="" method="POST">
                        {% csrf_token %}
                        {% for field in form %}
                            {% if not field.is_hidden %}
                                <label for='{{ field.id_for_label }}'>{{ field.label }}</label>
                            {% endif %}
                            {{ field }}
                            <p class="text-danger">{{ field.errors.as_text }}</p>   
                            <!-- 此处报错，是LoginForm类中各属性分别校验时返回的错误，也就是在clean_xxx不同属性时抛出的错误 field.errors.as_text -->
                        {% endfor %}
                        <span class="pull-left text-danger">{{ form.non_field_errors }}</span>
                        {# 这里login_form.non_field_errors返回的值为forms.py中raise抛出的值 #}
                        <!-- 这里的报错，是LoginForm类中clean抛出的错误值 -->
                        <div class="pull-right">   {# 这里这个元素pull-right是将下面的元素都靠右 #}
                            <button class="btn btn-default" onclick="window.location.href='{{ return_back_url }}'">返回</button>
                        </div>
                            <input type="submit" value="{{ submit_title }}" class="btn btn-primary pull-right">
                    </form>
                    </div>
                </div>
            </div>
        </div>
    </div>
{% endblock %}
```















