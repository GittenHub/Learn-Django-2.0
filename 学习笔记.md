# Learn-Django-2.0
B站课程学习https://www.bilibili.com/video/BV1GW411Y7EU

# 课程源码地址

https://github.com/HaddyYang/django2.0-course

# 目录

[TOC]

----------

# 课程基本信息

https://www.bilibili.com/video/BV1GW411Y7EU
**版本情况：**

# 环境配置

**官网文档：**
https://docs.djangoproject.com/zh-hans/2.1/
**下载Django：**

```
$ conda activate envs (envs) 
$ pip install Django==2.0
```

# 02.入门仪式：Hello World

## 创建项目命令：

```
$ django-admin startproject<项目名>
```

## Django项目基本结构

![](https://raw.githubusercontent.com/GittenHub/GittenPicRepo/master/Image.png)

## 响应请求

![](https://raw.githubusercontent.com/GittenHub/GittenPicRepo/master/Imag1e.png)

## 根目录下创建views.py

```python
#views.py  创建一个index方法
from django.http import HttpResponse

def index(request):
	return HttpResponse("Hello, world")
```

## 在urls.py中新建一个路由

```python
#urls.py 
from django.contrib import admin 
from django.urls import path 
from . import views 

urlpatterns = [     
    path('admin/', admin.site.urls),#后台管理网址     
    path('', views.index),   #设置一个空的路由，不设置就是ip后没有目录，需要创建一个方法 ]
```

## re_path与path的区别

是否使用正则表达式

## 启动本地服务

```
/mysite $ python manage.py runserver
```

## 迁移数据库

```
/mysite $ python manage.py migrate
```

数据库类型修改在settings.py中

## 默认后台管理

http://127.0.0.1:8000/admin

## 创建超级用户

```
$ python manage.py createsuperuser
```

账号：gitten
密码：guoyiteng

>命令行帮助：python manage.py help

# 03.基本响应结构

## 多种相似结构的页面处理方式

![](https://raw.githubusercontent.com/GittenHub/GittenPicRepo/master/Image2.png)
抽象处理为模型

## 创建一个应用

```
$ python manage.py startapp <应用名称>
```

编辑settings.py文件

```python
#settings.py
INSTALLED_APPS = [
    'django.contrib.admin',
  	...,
    'article'  
]
```

## 同步数据库

```
$ python manage.py makemigrations  #制造迁移
$ python manage.py migrate  #迁移
```

## 将app添加到网站的后台管理

编辑article这个app文件夹下的admin.py

## 将网站后台修改为中文

修改settings.py文件

```python
#settings.py
...
LANGUAGE_CODE = 'zh-Hans'
```


# 04.使用模版显示内容

## 查看文章页面

```python
# article/views.py
from django.shortcuts import render
from django.http import HttpResponse
from .models import Article  #引用创建的模型

# Create your views here.
def article_detail(request,article_id):
	return HttpResponse("文章id: %s" % article_id)
```

```python
# urls.py
from django.contrib import admin
from django.urls import path
from . import views
from article.views import article_detail  #引用article包中views的article_detail方法

urlpatterns = [
   ...
    path('article/<int:article_id>', article_detail, name="article_detail"), #本行中的<int:article_id>代表这是一个整数变量，且变量名与对应views中的处理方法传递的参数相同;name是表示别名
]
```

## Objects

模型的objects是获取哦操作模型的对象

```python
Article.objects.get(条件)
Article.objects.all()
Article.objects.filter(条件)
```

### objects.get()

```python
from django.shortcuts import render
from django.http import HttpResponse
from .models import Article

# Create your views here.
def article_detail(request,article_id):
	article = Article.objects.get(id=article_id)  # 创建一个名为article的对象
	return HttpResponse("<h2>文章标题： %s </h2> <br>文章内容： %s " % (article.title,article.content)) 
	#使用article对象中的title属性
```

#### .get()方法错误异常处理

try、except

```
from django.shortcuts import render
from django.http import HttpResponse,Http404
from .models import Article

# Create your views here.
def article_detail(request,article_id):
	try:    #使用try  except  处理异常
		article = Article.objects.get(id=article_id)  # 创建一个名为article的对象
	except Article.DoesNotExist:
		#return HttpResponse("不存在")
		raise Http404("not exist")
	return HttpResponse("<h2>文章标题： %s </h2> <br>文章内容： %s " % (article.title,article.content)) 
	#使用article对象中的title属性
```

get_object_or_404处理异常，如果查询的对象不存在的话，会抛出一个Http404的异常

```python
from django.shortcuts import render,render_to_response,get_object_or_404 
from .models import Article

def article_detail(request,article_id):
		article = get_object_or_404(Article,pk=article_id) #两个参数，1、模型；2、条件主键
		context = {}
		context ['article_obj'] = article 
		return render_to_response("article_detail.html",context) 
```



## 使用模板

1. 在mysite/article下新建文件夹<templates>

2. 在templates文件中新建HTML文件“article_detail.html"

   ```
   <!DOCTYPE html>
   <html>
   <head>
   	<title></title>
   </head>
   <body>
   	<h2>{{article_obj.title}}</h2>
   	<hr>
   	<p>{{article_obj.content}}</p>
   </body>
   </html>
   ```

   其中`{{}}`中的内容用于传递参数

> 查找翻看Django源代码，在Python的安装路径下/Lib/site-packages/django/包名



## 获取文章列表

1. 在urls.py中配置路径

2. 在views.py中新建方法

3. 在HTML模板中使用for语句和url标签

   ```html
   {% for article in articles %}  <!-- 模板中的for语句 -->
   <!-- <a href="/article/{{article.pk}}">{{article.title}}</a> -->
   <a href="{% url 'article_detail' article.pk %}">{{article.title}}</a>   <!-- 模板中的URL标签 -->
   {% endfor %}
   ```



## 总urls包含app的urls

1. 在“article”APP中新建APP的urls.py文件
2. 在总路由urls.py文件中使用include将article中的urls引用过来

```python
# article/urls.py
from django.urls import path
from . import views

urlpatterns = [
	#localhost:8000/article/
    path('<int:article_id>', views.article_detail, name="article_detail"), #本行中的<int:article_id>代表这是一个整数变量，且变量名与对应views中的处理方法传递的参数相同;name是表示别名
    #localhost:8000/article/1
    path('', views.article_list, name="article_list"), 
]
```

```python
# 修改总路由urls.py文件的内筒，使用include
from django.contrib import admin
from django.urls import path,include
from . import views
from article.views import article_detail,article_list

urlpatterns = [
    path('admin/', admin.site.urls),#后台管理网址
    path('', views.index),   #设置一个空的路由，不设置就是ip后没有目录，需要创建一个方法
    path('article/', include('article.urls')), #使用include引用app中的urls.py
]
```



# 05.定制后台和修改模型

https://www.bilibili.com/video/BV1LW411877A/

## 定制admin后台

设置模型\__str__

### 修改article/modles.py

```python
from django.db import models
# Create your models here.
class Article(models.Model):
	title = models.CharField(max_length=30) 
	content = models.TextField()  #用了两种字段模型来穿件类中的两个属性

	def __str__(self):  #在这个类中添加一个方法  标注具体是什么对象
		return "<Article: %s>" % self.title
```

### 修改article/admin.py

```python
from django.contrib import admin
from .models import Article

# Register your models here.在这里注册你的模型
class ArticleAdmin(admin.ModelAdmin):
	list_display = ("title","content")  #元组或列表  最好元组

admin.site.register(Article,ArticleAdmin)
```

修改前的admin界面：

![](https://raw.githubusercontent.com/GittenHub/GittenPicRepo/master/20200705233931.png)

修改后：

![](https://raw.githubusercontent.com/GittenHub/GittenPicRepo/master/20200706133259.png)

### 修改id排序（降序、升序）：

#### 在admin.py中修改

```python
class ArticleAdmin(admin.ModelAdmin):
	list_display = ("id","title","content")  #元组或列表  最好元组
	ordering = ("id",)  #注意在这要加一个逗号，代表是一个元组，否则识别为普通括号
  #ordering = ("-id",)  #倒序
```

#### 在models.py中修改



## 修改模型

> 修改模型后需要生成迁移文件，再迁移
>
> ` python manage.py makemigrations`
>
> ` python manage.py migrate`

> 修改模型前备份数据库

### 让文章显示创建日期的三种方法（设置默认值）

1. 修改models.py，在Article类中增加属性`created_time = models.DateTimeField()`，然后在admin.py中的ArticleAdmin中的list_display属性元组中增加"created_time"字段，迁移启动服务器后，在终端中设置：选择1，输入timezone.now
2. 修改admin.py直接在Article类中增加属性`created_time = models.DateTimeField(default=timezone.now)`设置默认值为现在的日期（记得import）
3. 在`models.DateTimeField(auto_now_add = True) `使用默认参数`auto_now_add = True`



### 外间 作者的名称

Django自带用户模型，在模型中的Article类中新增author属性，用models.ForeignKey()关联外键到User库

```python
#article/models.py/Article
from django.contrib.auth.models import User   #引入用户包

class Article(models.Model):
    author = models.ForeignKey(User, on_delete=models.DO_NOTHING, default=1) 
	#几个参数：1、关联到哪个表；2、文章删除时是否删除作者；3、默认值，在这作者对应的外键的值

```

再在admin.py中增加"author"

### 文章逻辑删除

```python
#article/models.py/Article
from django.db import models

class Article(models.Model):
    is_deleted = models.BooleanField(default=False)  #逻辑删除，而不是真实在数据库中删除
	readed_num = models.IntegerField(default=0)  #阅读量
```

再在admin.py中增加"is_deleted"、""

文章列表（http://127.0.0.1:8000/article/）中不显示逻辑删除的文章：

```python
#article/views.py
def article_list(request):
	articles = Article.objects.filter(is_deleted = False)  #只筛选出未逻辑删除的文章
```





# 06.开始完整制作网站

动力影响学习的热情



## 如何用Django开发网站

要做什么

设计网站圆形

具体开发

测试

部署上线



业务流程

功能木块

前端布局

后端模型



## 接下来的教程

### 目的

1. 通过完整的开发过程学习Django
2. 对一般的网站开发有全面的认识

### 个人博客网站

- 项目管理
  - IDE
  - 本地虚拟环境
  - Git/Github

- 前端开发
  - HTML + JavaScript + CSS
  - jQuery
  - Bootstrap
  - ajax
- 后端开放
  - 博客管理和展示
  - 用户登录和注册
  - 评论和回复
  - 点赞
- 数据库和服务器
  - MySQL
  - linux（centos、Ubuntu）
  - 网站部署

### IDE

记事本

vim/Emacs

sublime text

PyCharm



# 07.构建个人博客网站

## 1.简单构建

网站的功能模块：

- 博客
  - 博文
  - 博客分类
  - 博客标签
- 评论
  - 
- 点赞
- 阅读
- 用户-->第三方登录（QQ/微博）

> 功能模块 ≈ Django App



## 2.开启本地虚拟环境

隔开python项目的运行环境

1. 避免多个项目之间python库的冲突
2. 完整便捷到处python库的列表

`$ pip install virtualenv`

## 3.virtualenv的使用方法

- 创建：`virtualenv<虚拟环境名称>`
- 启动：`$ cd 虚拟环境名称\Scripts\activate`  
- 退出：`deactivate`

## 4.初步创建blog应用

博文 + 博客分类

- 一篇博客一种分类，本教程采用这种
- 一篇博客多种分类

```
django-admin startproject mysite
python manage.py startapp blog
python manage.py migrate
python manage.py createsuperuser
```

> 用户名：gitten
>
> 密码：guoyiteng



## 5.pip一键到处和安装（拓展）

`pip freeze > requirements.txt`

`pip install -r requirements.txt`



# 08.常用的模版标签和过滤器

## 1、继续搭建blog

- [x] models 
- [x] admin
- [ ] views
- [ ] urls
- [ ] templates

在blog/models.py中新建两个类

在blog/views.py中新建两个方法

在blog文件夹下新建templates文件夹，再在templates中新建blog_list.html和blog_detail.html

在blog文件夹下新建urls.py文件，再在总urls.py文件中做好路由映射

## 2、常用的模板标签

- 循环： for
- 条件： if（可逻辑判断）、ifequal、ifnotequal
- 链接： url
- 模板嵌套：block、extends、include
- 注释：{# #}

### 标签

```html
 <h3>{{ blog.title }}</h3>   
{% url 'blog_detail' blog.pk %}
```

两种均为标签

## 3、常用的过滤器

- 日期：date
- 字数截取：truncatechars、truncatechars_html、truncatewords、truncatewords_html
- 是否信任html：safe
- 长度：length

> 参考：https://docs.djangoproject.com/zh-hans/2.0/ref/templates/builtins/

```html
<p>一共有{{ blogs|length }}篇博客</p>
<p>发表日期：{{ blog.created_time|date:"Y-m-d h:n:s" }}</p>
```

### 在templates中的html里使用过滤器

```html
<p>{{ blog.content|truncatechars:30 }}</p>   <!-- 过滤器，显示前30个字符 -->
<p>{{ blog.content|truncatewords:30 }}</p>   <!-- 过滤器，显示前30个英文单词，空格隔开 -->
```





# 09.模板嵌套

## 1、常用的模板标签

- 循环： for
- 条件： if（可逻辑判断）、ifequal、ifnotequal
- 链接： url
- 模板嵌套：block、extends、include
- 注释：{# #}

## 2、全局模板文件夹

在mysite总目录下心间templates文件夹

然后修改 settings.py -->TEMPLATES --> DIRS

```python
'DIRS': [
            os.path.join(BASE_DIR, 'templates'),    #定义全局模板文件夹路径
        ],
```



## 3、模板文件设置建议

- app模板文件 --> app
- project模板文件 --> project



# 10.使用CSS美化页面

## 1、页面设计

- 导航栏
- 主题内容
- 尾注

### 导航栏设计

LOGO网站名称 + 导航

xxxxx的网站   首页  博客

## 2、使用CSS

CSS ：层叠样式表   修饰HTML

韩顺平老师  学习html+css   w3cschool

##  3、使用静态文件

CSS代码  -->  CSS文件（js文件、图片）  统称为静态文件

设置静态文件的路径，在settings.py最后增加

```python
STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'static'),   #设置静态文件的路径
]
```



### 方法一：直接在HTML模板中引入css

```html
<link rel="stylesheet" type="text/css" href="/static/base.css">
```

### 方法二：load staticfiles

在模板文件中

```html
{% load staticfiles %}

<link rel="stylesheet" type="text/css" href="{% static 'base.css' %}">
{% block header_extends %}{% endblock %}
```

```html
{% load staticfiles %}

{% block header_extends %}
    <link rel="stylesheet" type="text/css" href="{% static 'home.css'%}">
{% endblock %}
```



# 11.CSS框架协助前段布局

## 1、为什么用CSS框架

1. 不会或不怎么会CSS
2. 不知道如何设计前段样式
3. 从头到尾写整个网站的CSS代码量大
4. ...

##  2、如何选择CSS框架

- 易用性
- 兼容性
- 大小
- 效果
- 功能

### bootstrap

- 文档齐全，使用简单
- 兼容较多浏览器
- 非轻量级
- 扁平、简洁
- 组件齐全、响应式

## 3、部署Bootstrap

1. 打开bootstrap[www.bootcss.com](www.bootcss.com)
2. 下载bootstrap（选择用于生产环境的bootstrap）
3. 引用bootstrap
4. 开始使用

### bootstrap基本模板

1. 中文语言设置

   ```HTML
   <html lang="zh-CN">
   ```

2. 头信息设置

   ```html
   <meta charset="utf-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">  
   <!-- 告诉ie浏览器使用什么内核 -->
   <meta name="viewport" content="width=device-width, initial-scale=1">
   <!-- 响应式布局 -->
   ```

   

# 12.Bootstrap响应式布局

> 同时打开两个Django项目的runserver
>
> `python manage.py runserver 8001  #默认为8080端口，设置其他端口则直接加在最后`

## 1、Bootstrap的响应式设计

适应4种屏幕大小，12列布局

- <768px （手机）
- \>=768px （平板）
- \>=992px （小尺寸显示器）
- \>=1200px （大尺寸显示器）

### 栅格参数

通过下表可以详细查看 Bootstrap 的栅格系统是如何在多种屏幕设备上工作的。

|                       | 超小屏幕 手机 (<768px)     | 小屏幕 平板 (≥768px)                                | 中等屏幕 桌面显示器 (≥992px) | 大屏幕 大桌面显示器 (≥1200px) |
| :-------------------- | :------------------------- | :-------------------------------------------------- | :--------------------------- | :---------------------------: |
| 栅格系统行为          | 总是水平排列               | 开始是堆叠在一起的，当大于这些阈值时将变为水平排列C |                              |                               |
| `.container` 最大宽度 | None （自动）              | 750px                                               | 970px                        |            1170px             |
| 类前缀                | `.col-xs-`                 | `.col-sm-`                                          | `.col-md-`                   |          `.col-lg-`           |
| 列（column）数        | 12                         |                                                     |                              |                               |
| 最大列（column）宽    | 自动                       | ~62px                                               | ~81px                        |             ~97px             |
| 槽（gutter）宽        | 30px （每列左右均有 15px） |                                                     |                              |                               |
| 可嵌套                | 是                         |                                                     |                              |                               |
| 偏移（Offsets）       | 是                         |                                                     |                              |                               |
| 列排序                | 是                         |                                                     |                              |                               |

### 布局容器

Bootstrap 需要为页面内容和栅格系统包裹一个 `.container` 容器。我们提供了两个作此用处的类。注意，由于 `padding` 等属性的原因，这两种 容器类不能互相嵌套。

`.container` 类用于固定宽度并支持响应式布局的容器。

```
<div class="container">
  ...
</div>
```

`.container-fluid` 类用于 100% 宽度，占据全部视口（viewport）的容器。

```
<div class="container-fluid">
  ...
</div>
```



## 2、基本结构

```html
<div class="container">
  	<div class="row">
	      <div class="col-xx-*"></div>
      	<div class="col-xx-*"></div>
	  </div>
</div>
```





## 3、Django静态文件命名空间

为了避免冲突

可以在app文件夹下的static文件夹中心间app名称的文件夹，再将css等静态文件放入其中，在应用css前加`static/app/xxx.css`



# 13.分页和shell命令行模式

## 1、为什么先将分页功能

1. 新增或编辑博客内容

2. 博客文章数较多->全部加载过慢->分页加载

   为了夯实基础，借机讲shell模式、模型操作、模版标签、分页器

## 2、快速添加博客

### shell命令行模式添加博客

1. `python manage.py shell`
2. `for`循环执行新增博客代码

## 3、模型新增对象

```python
from blog.models import Blog
blog = Blog()
blog.title = 'xxx'
...
blog.save()
```

### terminal操作

```python
Last login: Mon Jul 13 14:12:14 on ttys000
gitten@Gittens-Macbook mysite % conda activate django2.0
(django2.0) gitten@Gittens-Macbook mysite % python manage.py shell
Python 3.8.3 (default, Jul  2 2020, 11:26:31) 
[Clang 10.0.0 ] on darwin
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
>>> from blog.models import Blog
>>> dir()
['Blog', '__builtins__']
>>> Blog.objects.all()
<QuerySet [<Blog: Blog: 长内容的博客>, <Blog: Blog: 随笔2>, <Blog: Blog: Django1>]>
>>> Blog.objects.count()
3
>>> Blog.objects.all().count()
3
>>> blog = Blog()
>>> dir()
['Blog', '__builtins__', 'blog']
>>> Blog.objects.all()
<QuerySet [<Blog: Blog: 长内容的博客>, <Blog: Blog: 随笔2>, <Blog: Blog: Django1>]>
>>> blog.title = "shell下第1篇"
>>> blog.content = "xxxxxx"
>>> from blog.models import BlogType
>>> BlogType.objects.all()
<QuerySet [<BlogType: Django>, <BlogType: 随笔>, <BlogType: 感悟>]>
>>> BlogType.objects.all()[0]
<BlogType: Django>
>>> blog_type = BlogType.objects.all()[0]
>>> blog.blog_type = blog_type
>>> from django.contrib.auth.models import User
>>> User.objects.all()
<QuerySet [<User: gitten>]>
>>> user = User.objects.all()[0]
>>> blog.author = user
>>> blog.save()
>>> Blog.objects.all()
<QuerySet [<Blog: Blog: 长内容的博客>, <Blog: Blog: 随笔2>, <Blog: Blog: Django1>, <Blog: Blog: shell下第1篇>]>
>>>
>>>
>>>
>>>
>>> for i in range(1,31):
...     blog = Blog()
...     blog.title = "for %s" %i
...     blog.content = "xxxxx:%s" % i
...     blog.blog_type = blog_type
...     blog.author = user
...     blog.save()
... 
>>> Blog.objects.all().count()
34
```

## 4、分页器实现分页

![](https://gitee.com/gitten/PicBed/raw/master/20200714102155.png)



```python
(django2.0) gitten@Gittens-Macbook mysite % python manage.py shell
Python 3.8.3 (default, Jul  2 2020, 11:26:31) 
[Clang 10.0.0 ] on darwin
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
>>> dir()
['__builtins__']
>>> from django.core.paginator import Paginator
>>> from blog.models import Blog
>>> blogs = Blog.object.all()
Traceback (most recent call last):
  File "<console>", line 1, in <module>
AttributeError: type object 'Blog' has no attribute 'object'
>>> blogs = Blog.objects.all()
>>> blogs.count()
34
>>> paginator = Paginator(blogs,10)
<console>:1: UnorderedObjectListWarning: Pagination may yield inconsistent results with an unordered object_list: <class 'blog.models.Blog'> QuerySet.
# 这里报了一个错误，是因为我们在models中没有设置默认排序方式，去修改
>>> 
```

### 修改models.py的默认排序方式

## 5、分页的使用

前端：发送请求，请求打开具体分页内容

后端：处理情况，返回具体分页内容相应情况

` http://127.0.0.1:8000/blog/?page=4`中的`?page=4`表示GET传递的参数





# 14. 优化分页展示

## 1、优化页面展示

友好的用户体验

1. 当前页面高亮
2. 不好过多页码选择，影响布局



> shift + F5  ： 强制刷新服务器



## 2、settings自定义设置

公用全局设置可放在settings中，统一管理

`from django.conf import settings`

`settings.XXX`



# 15. 上下篇博客和按月分类



## 1、上一篇和下一篇博客

对比当前博客，得到上一篇或下一篇

##  2、filter筛选条件

等于：直接筛选

其他常用查找类型：

- 大于：__gt(greater than)

  ```python
  context['previous_blog'] = Blog.objects.filter(created_time__gt=blog.created_time).last()  
  #取创建时间比当前博客大的博客列表中的最后一条
  ```

- 大于等于：__gte

- 小于：__lt(less than)

- 小于等于：__lte

  > 上述这些大多用于数字的比较

- 包含：__contains(加i忽略大小写)

  ```python
  >>> from blog.models import Blog
  >>> Blog.objects.filter(title__contains='django')
  <QuerySet [<Blog: Blog: Django1>]>   #因为sqlite不区分大小写，所以也筛选出来了
  >>> Blog.objects.filter(title__icontains='django')
  <QuerySet [<Blog: Blog: Django1>]>
  ```

- 开头是：__startswith

- 结尾是：__endswith

  > 字符串大多用饱含、开头是、结尾是

- 其中之一：__in

- 范围：__range

  ```python
  >>> Blog.objects.filter(id__in=[1, 3, 4])
  <QuerySet [<Blog: Blog: 随笔2>, <Blog: Blog: 长内容的博客>]>
  >>> Blog.objects.filter(id__range=(3, 6))
  <QuerySet [<Blog: Blog: shell下第1篇>, <Blog: Blog: Django1>, <Blog: Blog: 随笔2>, <Blog: Blog: 长内容的博客>]>
  ```

## 3、exclude排除条件

filter无法去筛选“不符合某种条件”的对象

exclude的用法和filter一样，都是得到查询（QuerySet）

相当于filter条件取反

filter等于 => 不等于

```python
>>> Blog.objects.exclude(pk=3)   # 筛选出pk不等于3的博客
<QuerySet [<Blog: Blog: for 30>, <Blog: Blog: for 29>, <Blog: Blog: for 28>, <Blog: Blog: for 27>, <Blog: Blog: for 26>, <Blog: Blog: for 25>, <Blog: Blog: for 24>, <Blog: Blog: for 23>, <Blog: Blog: for 22>, <Blog: Blog: for 21>, <Blog: Blog: for 20>, <Blog: Blog: for 19>, <Blog: Blog: for 18>, <Blog: Blog: for 17>, <Blog: Blog: for 16>, <Blog: Blog: for 15>, <Blog: Blog: for 14>, <Blog: Blog: for 13>, <Blog: Blog: for 12>, <Blog: Blog: for 11>, '...(remaining elements truncated)...']>
```

##4、条件中的双下划线

1. 字段查询类型
2. 外键拓展（以博客分类为例）
3. 日期拓展（以月份分类为例）
4. 支持链式查询：可以一直链接下去

# 16.博客分类统计

## 1、annotat注释

使用annotate拓展查询字段

```python
context['blog_types'] = BlogType.objects.annotate(blog_count=Count('blog'))
```



# 17. 博客后台富文本编辑

## 1、使用html丰富页面

- 简繁文本编辑
  - 直接贴入html代码
- 富文本编辑
  - 最终解析成html
    - 富文本编辑器
    - markdown编辑器

### 直接贴入html

直接写入因为安全问题，无法识别为html语言，需要在模板文件中修改修饰器`{{ blog.content|safe }}`在后面增加safe

```python
<div class="blog-content">{{ blog.content|safe }}</div>   
```

但此时列表中的内容简述会有html语句

在列表html文件中修改模板文件，增加修饰器`|striptags`，表示忽略html标签

```django
<p>{{ blog.content|striptags|truncatechars:120 }}</p>
```

## 2、使用django-ckeditor富文本编辑器

**选择标准：**

- 具有基本的富文本编辑功能
- 可以上传图片
- 可以查看源码
- 有持续更新（维护）

## 3、安装django-ckeditor

1. 安装

   `pip install django-ckeditor`

2. 注册应用

   'ckeditor'

3. 配置model

   把字段改为RichTextField

> Django-ckeditor在语言设置为zh-Hans时有识别错误为繁体，改为zh-hans就可以了

## 4、添加上传图片功能

1. 安装

   `pip install pillow`  pillow是一个用于处理图片的库

2. 注册应用

   ```
    INSTALLED_APPS = [
       'ckeditor_uploader',
   ]
   ```

3. 配置settings.py，在最后增加

   ```python
   # media配置
   MEDIA_URL = '/media/'
   MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
   
   # 配置ckeditor
   CKEDITOR_UPLOAD_PATH = 'upload/'
   ```

4. 配置url.py

   ```python
   urlpatterns = [
       path('ckeditor', include('ckeditor_uploader.urls')),
   ]
   
   urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
   ```

5. 配置model

   此时models类中仍不能上传文件，将其修改至如下：

   ```python 
   from ckeditor_uploader.fields import RichTextUploadingField
   
   class Blog(models.Model):  
       content = RichTextUploadingField()
   ```

> 这些配置都可以在pypi.python.org网站中找到，搜索'django-ckeditor'



# 18.博客阅读简单计数

## 1、简单计数处理

1. Blog模型添加数字字段记录
2. 每次有人打开，记录数+1

## 2、自定义技术规则

可规定，怎么才算阅读一次

1. 无视是否同一人，每次打开都记录
2. 若同一个人，每隔多久才算阅读一次

```python
def blog_detail(request,blog_pk):
    blog = get_object_or_404(Blog, pk=blog_pk)
    if not request.COOKIES.get('blog_%s_readed' % blog_pk):
        blog.readed_num += 1
        blog.save()
    context = {}
    context['blog'] = blog
    context['previous_blog'] = Blog.objects.filter(created_time__gt=blog.created_time).last()  # 取创建时间比当前博客大的博客列表中的最后一条
    context['next_blog'] = Blog.objects.filter(created_time__lt=blog.created_time).first()  # 取创建时间比当前博客小的博客列表中的第一条｜可以将first()替换为[0]进行切片
    response = render_to_response('blog/blog_detail.html',context)  # 响应
    #response.set_cookie('blog_%s_readed' % blog_pk, 'true', max_age=60, expires=datetime()) # max_age有效时间以秒计,expires设置一个datetime，两者冲突
    response.set_cookie('blog_%s_readed' % blog_pk, 'true')
    return response
```



## 3、该技术方法缺点

1. 后台编辑博客可能影响数据

   更新时会影响统计，同时访问时会影响编辑最后时间

1. 功能单一，无法统计某一天的阅读量



# 19.博客阅读计数优化

## 1、简单计数方法的缺点

1. 后台编辑博客可能影响数据

   更新时会影响统计，同时访问时会影响编辑最后时间

1. 功能单一，无法统计某一天的阅读量

## 2、计数功能独立

- 博客内容 Blog
- 计数字段 Read Num
- 通过外键关联起来

![](https://gitee.com/gitten/PicBed/raw/master/20200725140250.png)

### 在model.py中新建一个类

```python
class ReadNum(models.Model):
    read_num = models.IntegerField(default=0)
    blog = models.OneToOneField(Blog, on_delete=models.DO_NOTHING)  
    # OneToOneField表示一对一，ForeignKey表示多对一，ManyToManyField表示多对多;on_delete 删除阅读数时是否删除博客;
```

### 迁移数据库文件

### 编辑admin.py

```python
@admin.register(ReadNum)
class ReadNumAdmin(admin.ModelAdmin):
    list_display = ('read_num', 'blog')
```

### django多对一模型间的关系

![](https://gitee.com/gitten/PicBed/raw/master/20200725141445.png)

> `Blog.objects.first().blog_type.blog_set.all()`可查看第一条博客所属类型的所有博客

### ReadNum与Blog外键关联后，可通过小写相互调用

`Blog.objects.first().readnum` 可返回ReadNum的对象

`Blog.objects.first().readnum.read_num` 可返回第一条博客的阅读数

### 在Blog中增加一个方法`get_read_num`

```python
class Blog(models.Model):
		...
    def get_read_num(self):
        try:
            return self.readnum.read_num   # 在将Blog和ReadNum关联后可以通过小写的方式调用另一个类的属性
        except exceptions.ObjectDoesNotExist as e: # 如果返回错误是对象不存在，则
            return 0
        
```

### 判断是否阅读过，修改views.py中的blog_detail方法

```python
def blog_detail(request,blog_pk):
    blog = get_object_or_404(Blog, pk=blog_pk)
    if not request.COOKIES.get('blog_%s_readed' % blog_pk):
        if ReadNum.objects.filter(blog=blog).count():   # 等于0为false，不为零就是true
            # 存在记录
            readnum = ReadNum.objects.get(blog=blog)    
        else:
            # 不存在对应的记录
            readnum = ReadNum(blog=blog)
        # 计数加一
        readnum.read_num += 1
        readnum.save()

    context = {}
    context['blog'] = blog
    context['previous_blog'] = Blog.objects.filter(created_time__gt=blog.created_time).last()  # 取创建时间比当前博客大的博客列表中的最后一条
    context['next_blog'] = Blog.objects.filter(created_time__lt=blog.created_time).first()  # 取创建时间比当前博客小的博客列表中的第一条｜可以将first()替换为[0]进行切片
    response = render_to_response('blog/blog_detail.html',context)  # 响应
    #response.set_cookie('blog_%s_readed' % blog_pk, 'true', max_age=60, expires=datetime()) # max_age有效时间以秒计,expires设置一个datetime，两者冲突
    response.set_cookie('blog_%s_readed' % blog_pk, 'true') 
    return response
```

## 3、可以对任意模型计数

![](https://gitee.com/gitten/PicBed/raw/master/20200725144433.png)

### ContentType：

记录了Django中所有模型，建立了一个表（也就是模型ContentType）

### 创建新的app：read_statistics

```python 
python manage.py startapp
```

注册新的app

### 修改阅读计数app下的models

```python
from django.db import models
from django.contrib.contenttypes.fields import GenericForeignKey
from django.contrib.contenttypes.fields import ContentType

class ReadNum(models.Model):
    read_num = models.IntegerField(default=0)

    content_type = models.ForeignKey(ContentType, on_delete=models.DO_NOTHING)
    # 关联外键到ContentType，再通过ContentType关联到相应的其他模型
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey('content_type', 'object_id') # 将上述两个属性结合创建一个外键
```

> Python 代码规范：先官方库 > 第三方库 > 我们自己的

迁移文件，在admin界面显示

### 通过shell分析Blog、ContentType、ReadNum三者间的关系

![image-20200725152905864](/Users/gitten/Library/Application Support/typora-user-images/image-20200725152905864.png)

ContentType 居中将Blog、ReadNum链接在一起

其中关键语句为`content_type = models.ForeignKey(ContentType, on_delete=models.DO_NOTHING)`

### 新建ReadNumExpandMethod，并让blog/models中的Blog继承这个类

ReadNumExpandMethod：

```python
from django.db import models
from django.db.models.fields import exceptions

class ReadNumExpandMethod():
    def get_read_num(self):
        try:
            ct = ContentType.objects.get_for_model(self)
            readnum = ReadNum.objects.get(content_type=ct, object_id=self.pk)
            return readnum.read_num
        except exceptions.ObjectDoesNotExist:
            return 0
```

ReadNumExpandMethod通过try来判断时候ReadNum中有博客对应的阅读数，有的话返回值，没有的话返回0

blog/models/Blog:

```python
from read_statistics.models import ReadNumExpandMethod

class Blog(models.Model, ReadNumExpandMethod): # 继承ReadNumExpandMethod中的属性
  	...
```

Blog继承ReadNumExpandMethod类中的get_read_num方法

此时blog/admin中就可以直接新增" get_read_num "了

```python
@admin.register(Blog)
class BlogAdmin(admin.ModelAdmin):
    list_display = ('id', 'title', 'blog_type', 'author', 'get_read_num', 'created_time', 'last_updated_time') 
```

### 在read_statistics中新建utils.py作为工具包

```python
from django.contrib.contenttypes.models import ContentType
from .models import ReadNum

def read_statistic_once_read(request, obj):
    ct = ContentType.objects.get_for_model(obj)
    key = "%s_%s_read" % (ct.model, obj.pk)
    if not request.COOKIES.get(key):
        if ReadNum.objects.filter(content_type=ct, object_id=obj.pk).count():   # 等于0为false，不为零就是true
            # 存在记录
            readnum = ReadNum.objects.get(content_type=ct, object_id=obj.pk)    
        else:
            # 不存在对应的记录
            readnum = ReadNum(content_type=ct, object_id=obj.pk)
        # 计数加一
        readnum.read_num += 1
        readnum.save()
    return key
```

`read_statistic_once_read`方法接受request和一个类中的具体对象，判断是否有cookie，没有的话readnum自增1，并返回key，由views.py中的blog_detail设置cookie



# 20.阅读计数统计和显示

## 1、简单计数方法的缺点

1. 后台编辑博客可能影响数据

1. 功能单一，无法统计某一天的阅读量

##  2. 统计需要记录明细



## 3.使用图表显示数据

后台 + 前端

后台提供数据，前段使用数据

使用highcharts：www.hcharts.cn





# 21. 热门阅读博客排行及缓存提速

## 1、利用阅读量数据排行

- 24小时内 -> 今天数据统计
- 昨天 -> 昨天数据统计
- 一周
- 30天



### 一周

`objects.values()`可以按照该对象的属性与属性的值，转为键值对的list

再用annotate可对键值对list进行分组统计，annotate中的参数为`sum()`或`count()`等方法

#### 反向通用关系 GenericRelation

在blog/models.py中新增一个属性

```python
from django.db import models
from django.contrib.contenttypes.fields import GenericRelation

class Blog(models.Model, ReadNumExpandMethod):
    ...
    read_details = GenericRelation(ReadDetail) # 反向通用关系，这运河之后可直接调用对方了
    ...
```





## 2、每次都计算，耗时

策略：缓存数据，不用每次都计算

- 内存缓存：Memcached、Redis
- 数据库缓存
- 文件缓存

> 缓存：Django官网搜索  " cache "

### 设置settings.py

```python
# 数据库缓存设置
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.db.DatabaseCache',
        'LOCATION': 'my_cache_table',
    }
}
```

### 在views.py中import cache

```python
from django.core.cache import cache

hot_blogs_for_7_days = cache.get('hot_blogs_for_7_days')
if hot_blogs_for_7_days is None:
  hot_blogs_for_7_days = get_7_days_hot_blogs()
  cache.set('hot_blogs_for_7_days', hot_blogs_for_7_days, 3600)  #最后一个为有效期（秒）
  print('calc')
else:
  print('use cache')
```



# 番外篇：在pythonanywhere部署Django

教程网址：https://www.bilibili.com/video/BV1wW411p7hh/

进一步激发学习的激情

## 部署上线常见主机

1. pythonanywhere、heroku
2. 云主机：阿里云、亚马逊等等

pythonanywhere网址：www.pythonanywhere.com





# 22.评论功能设计和用户登录

## 1、实现评论功能的方式

1. 第三方社会化评论插件
   1. 友言、多说、倡言、Disqus、网易云跟帖
2. Django评论库
   1. django-comment
3. 自己写代码实现

## 2、创建评论模型

- 评论对象
- 评论内容
- 评论时间
- 评论者

startapp comment

Class comment

@admin.register(Comment)



## 3、评论需要登录用户

确保较低程度减少垃圾评论

也提高了评论员门槛（第三方登录）

还可以通知用户

### 在模板页面设置 【提交评论区】【评论列表】

```django
<div class="row">
  <div class="col-xs-10 col-xs-offset-1">
    <div style="margin-top: 2em;border: 1px dashed;padding: 2em;">提交评论区
      {% if user.is_authenticated %}
      已登录
      {% else %}
      未登录
      <form action="{% url 'login' %}" method="POST">
        {% csrf_token %}
        <input type="text" name="username">
        <input type="password" name="password">
        <input type="submit" value="登录">
      </form>
      {% endif %}
    </div>
    <div style="margin-top: 2em;border: 1px dashed;padding: 2em;">评论列表区</div>
  </div>
</div>
```

### 在urls.py中设置路由

```python
urlpatterns = [
    ...
    path('login/', views.login, name='login'),
]
```

### 在views.py中设置login登录方法

```python
from django.shortcuts import render, redirect
from django.contrib import auth

def login(request):
    username = request.POST.get('username', '')
    password = request.POST.get('password', '')
    user = auth.authenticate(request, username=username, password=password)
    if user is not None:
        auth.login(request, user)
        return redirect('/')
        
    else:
        return render(request, 'error.html', {'messeage':'用户名密码不正确'})
```

### 设置error.html

```django
{% extends 'base.html' %}
{% load staticfiles %}

{# 页面标题 #}
{% block title %}
    我的网站｜错误
{% endblock %}

{% block nav_home_active %}active{% endblock %}

{% block content %}
    {{ message }}
{% endblock %}
```





# 23. HTML表单提交评论

## 1、提交评论

- 评论对象
- 评论内容
- 评论时间
- 评论者

### 重定向：登录后自动跳转至刚才浏览的页面

mysite/views.py中使用redirect(referer)进行重定向  

```python
def login(request):
    username = request.POST.get('username', '')
    password = request.POST.get('password', '')
    user = auth.authenticate(request, username=username, password=password)
    #referer = request.META.get('HTTP_REFERER', '/')
    referer = request.META.get('HTTP_REFERER', reverse('home')) #反方向解析别名
    # referer表示，使用请求头META中，用get获取HTTP_REFERER(推荐人)，也就是这个请求前所在的网址, 如果没有HTTP_REFERER则跳转到首页
    # reverse表示进行反向解析，通过对别名home进行解析，得到链接地址
    if user is not None:
        auth.login(request, user)
        return redirect(referer)  # redirect表示进行重定向
    else:
        return render(request, 'error.html', {'message':'用户名密码不正确'})
```

### 在具体博客下方细分“提交评论”和“评论列表”

修改blog_detail.html文件

```django
<div class="row">
            <div class="col-xs-10 col-xs-offset-1">
                <div class="comment-area">
                    <h3 class="comment-area-title">提交评论</h3>
                {% if user.is_authenticated %}
                    <form action="{% url 'update_comment' %}" method="POST" style="overflow:hidden;">
                        {% csrf_token %}
                        <div class="form-group">
                            <label for="comment_text">{{ user.username }}，欢迎评论~</label>
                            <textarea id="comment_text" class="form-control" name="text" rows="4"></textarea>
                        </div>
                        
                        <input type="hidden" name="object_id" value="{{ blog.pk }}">
                        <input type="hidden" name="content_type" value="blog">
                        <input type="submit" value="评论" class="btn btn-primary" style="float:right">
                    </form>
                {% else %}
                    未登录，登录之后方可评论
                    <form action="{% url 'login' %}" method="POST">
                        {% csrf_token %}
                        <input type="text" name="username">
                        <input type="password" name="password">
                        <input type="submit" value="登录">
                    </form>
                {% endif %}
                </div>
                <div class="comment-area">
                    <h3 class="comment-area-title">评论列表</h3>
                    {% for comment in comments%}
                        <div>
                            {{ comment.user.username }}
                            ({{ comment.comment_time|date:"Y-m-d H:n:s" }}):
                            {{ comment.text }}
                        </div>
                    {% empty %}
                        暂无评论
                    {% endfor %}
                </div>
            </div>
        </div>
```

### form表单提交主要结构

```django
<form action="{% url 'update_comment' %}" method="POST" style="overflow:hidden;">
  {% csrf_token %}      {# 防止报错 #}
  <div class="form-group">
    <label for="comment_text">{{ user.username }}，欢迎评论~</label>
    <textarea id="comment_text" class="form-control" name="text" rows="4"></textarea>
  </div>
  <input type="hidden" name="object_id" value="{{ blog.pk }}">
  <input type="hidden" name="content_type" value="blog">
  <input type="submit" value="评论" class="btn btn-primary" style="float:right">
</form>
```

name表示键，value表示值，两者构成键值对，由action专递给路由别名“update_comment”——{% url 'update_comment' %}





### comment/urls.py

```python
urlpatterns = [
    path('update_comment', views.update_comment, name='update_comment'),    
]
```



### 提交表单后views中的函数

comment/views.py

``` python
from django.shortcuts import render, redirect
from django.contrib.contenttypes.models import ContentType
from django.urls import reverse
from .models import Comment


def update_comment(request):
    referer = request.META.get('HTTP_REFERER', reverse('home')) 
    # 转回到请求中的网址

    # 数据检查
    if not request.user.is_authenticated:
    # request.user.is_authenticated表示是否登录   
        return render(request, 'error.html', {'message':'用户未登录', 'redirect_to':referer})

    text = request.POST.get('text', '').strip()  # 获取不到为空
    if text == '':
        return render(request, 'error.html', {'message':'评论内容为空', 'redirect_to':referer})

    try:  # 进行错误处理，有可能content_type、object_id会有错误
        content_type = request.POST.get('content_type', '')
        object_id = int(request.POST.get('object_id', ''))
        model_class = ContentType.objects.get(model=content_type).model_class()
        # 使用ContentType进行处理，根据'content_type'得到blog等对象类型,ContentType.objects.get获得一个外键关联的具体的blog对象
        # 使用model_class方法，可以得到具体的模型的class, 也就是得到Blog；使用model_class方法，可以根据一个具体的object对象，返回这个对象所属的class类
        model_obj = model_class.objects.get(pk=object_id)
    except Exception as e:
        return render(request, 'error.html', {'message':'评论对象不存在', 'redirect_to':referer})

    # 检查通过，保存数据
    comment = Comment()
    comment.user = request.user
    comment.text = text
    comment.content_object = model_obj
    comment.save()

    return redirect(referer)
```



## 2、进一步讲解

django forms类

自定义模板标签



# 24. 使用Django Form表单提交

## 1、Django Form的作用

Django用Form类描述html表单，帮助或简化操作

1. 接受和处理用户提交的数据

   检查提交的数据

   可将数据转换成python的数据类型

2. 可自动生成HTML代码

## 2、Django Form的使用

![](https://gitee.com/gitten/PicBed/raw/master/20200728211639.png)

### 在mysite/下新建forms.py文件

```python
from django import forms

class LoginForm(forms.Form):
    username = forms.CharField(label='用户名', required=True) # label可定制html中的label标签; required=True表示这个字段一定要填写才能提交
    password = forms.CharField(label='密码', widget=forms.PasswordInput) # widget=forms.PasswordInput可定义在HTML中生成password类，隐藏密码
```

### 在mysite/views.py文件中`from .forms import LoginForm`，修改Login登录方法

```python
from .forms import LoginForm

def login(request):
    if request.method == 'POST':  # 如果请求中的提交方法为POST
        login_form = LoginForm(request.POST)
        if login_form.is_valid():  # 判断login_form是否有效
            username = login_form.cleaned_data['username']  # cleaned_data 表示是处理过的干净数据
            password = login_form.cleaned_data['password']
            user = auth.authenticate(request, username=username, password=password)
            if user is not None:   # 如果user存在
                auth.login(request, user)  # 登录
                return redirect(request.GET.get('from', reverse('home')))  
                # 利用在HTML模板文件中添加GET请求参数?from=，将之前的页面地址传递过来，如果没有则返回首页
            else:
                # form 自带一个错误集
                login_form.add_error(None, '用户名或密码不正确')  # add_error有两个参数，第一个为错误的参数名（可以为None），后面为文字提示
                context = {}
                context['login_form'] = login_form # 此时login_form携带了上面增加的错误信息
                return render(request, 'login.html', context)
        else:
            pass
    else:
        login_form = LoginForm()
        context = {}
        context['login_form'] = login_form
        return render(request, 'login.html', context)
```

将context['login_form']传递给前端模板页面

### 新建login.html

```django
{% extends 'base.html' %}
{% load staticfiles %}

{# 页面标题 #}
{% block title %}
    我的网站｜登录
{% endblock %}

{% block nav_home_active %}active{% endblock %}

{% block content %}
    <form action="#" method="POST">
        {% csrf_token %}
        {{ login_form }}
        <input type="submit" value="登录">
    </form>
{% endblock %}
```

### 在forms.py中验证用户名密码是否正确

修改forms.py

```python
from django import forms
from django.contrib import auth

class LoginForm(forms.Form):
    username = forms.CharField(label='用户名', required=True, widget=forms.TextInput) 
    # label可定制html中的label标签; required=True表示这个字段一定要填写才能提交
    password = forms.CharField(label='密码', widget=forms.PasswordInput(attrs={'class':'form-control'})) 
    # widget=forms.PasswordInput可定义在HTML中生成password类，以密文的形式隐藏密码.widget可定义这个form中一个字段的类型
    
    # 验证用户名密码是否正确
    def clean(self):
    # views.py中在进行.is_valid()，进行判断LoginForm是否有效时会使用这个方法
        username = self.cleaned_data['username']
        password = self.cleaned_data['password']

        user = auth.authenticate(username=username, password=password) 
        # .authenticate中的第一个参数request是可以不需要的
        if user is None:   
            raise forms.ValidationError('用户名或密码不正确')
            # 抛出错误raise
        else:
            self.cleaned_data['user'] = user
        return self.cleaned_data
            
```

简化views.py

```python
def login(request):
    if request.method == 'POST':  
    # 如果请求中的提交方法为POST，则提交POST中request的内容，否则渲染页面
        login_form = LoginForm(request.POST) # request.POST中包含了username等键值对
        # login_form = LoginForm({'username':'sss'}) 
        if login_form.is_valid():  # 判断login_form是否有效，并进行forms.py中的clean方法
            user = login_form.clean_data['user']
            auth.login(request, user)  # 登录
            return redirect(request.GET.get('from', reverse('home'))) 
            # redirect表示进行重定向 进行页面跳转，跳转到原来的页面，
            # 利用在HTML模板文件中添加GET请求参数?from=，将之前的页面地址传递过来，如果没有则返回首页
            
    else:
        login_form = LoginForm()

    context = {}
    context['login_form'] = login_form # 如果错误，此时login_form携带了上面增加的错误信息
    return render(request, 'login.html', context)
```

### 通过python manage.py shell查看forms的所有属性

```python
>>> from django import forms
>>> dir(forms)
['ALL_FIELDS', 'BaseForm', 'BaseFormSet', 'BaseInlineFormSet', 'BaseModelForm', 'BaseModelFormSet', 'BooleanField', 'BoundField', 'CharField', 'CheckboxInput', 'CheckboxSelectMultiple', 'ChoiceField', 'ClearableFileInput', 'ComboField', 'DateField', 'DateInput', 'DateTimeField', 'DateTimeInput', 'DecimalField', 'DurationField', 'EmailField', 'EmailInput', 'Field', 'FileField', 'FileInput', 'FilePathField', 'FloatField', 'Form', 'GenericIPAddressField', 'HiddenInput', 'ImageField', 'IntegerField', 'Media', 'MediaDefiningClass', 'ModelChoiceField', 'ModelForm', 'ModelMultipleChoiceField', 'MultiValueField', 'MultiWidget', 'MultipleChoiceField', 'MultipleHiddenInput', 'NullBooleanField', 'NullBooleanSelect', 'NumberInput', 'PasswordInput', 'RadioSelect', 'RegexField', 'Select', 'SelectDateWidget', 'SelectMultiple', 'SlugField', 'SplitDateTimeField', 'SplitDateTimeWidget', 'SplitHiddenDateTimeWidget', 'TextInput', 'Textarea', 'TimeField', 'TimeInput', 'TypedChoiceField', 'TypedMultipleChoiceField', 'URLField', 'URLInput', 'UUIDField', 'ValidationError', 'Widget', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', 'all_valid', 'boundfield', 'fields', 'fields_for_model', 'forms', 'formset_factory', 'formsets', 'inlineformset_factory', 'model_to_dict', 'modelform_factory', 'modelformset_factory', 'models', 'renderers', 'utils', 'widgets']
>>> list(filter(lambda x: 'Input' in x,dir(forms)))
['CheckboxInput', 'ClearableFileInput', 'DateInput', 'DateTimeInput', 'EmailInput', 'FileInput', 'HiddenInput', 'MultipleHiddenInput', 'NumberInput', 'PasswordInput', 'TextInput', 'TimeInput', 'URLInput']
>>> list(filter(lambda x: 'Field' in x,dir(forms)))
['BooleanField', 'BoundField', 'CharField', 'ChoiceField', 'ComboField', 'DateField', 'DateTimeField', 'DecimalField', 'DurationField', 'EmailField', 'Field', 'FileField', 'FilePathField', 'FloatField', 'GenericIPAddressField', 'ImageField', 'IntegerField', 'ModelChoiceField', 'ModelMultipleChoiceField', 'MultiValueField', 'MultipleChoiceField', 'NullBooleanField', 'RegexField', 'SlugField', 'SplitDateTimeField', 'TimeField', 'TypedChoiceField', 'TypedMultipleChoiceField', 'URLField', 'UUIDField']
>>> 
```

```
>>> list(filter(lambda x: 'Input' in x,dir(forms)))
# 查看forms中包含Input的所有属性
```



## 3、Form中`.is_valid()`方法校验机制

views.py中定义login函数时，需要对构建的login_form进行校验

```python
def login(request):
    if request.method == 'POST':  
        login_form = LoginForm(request.POST) # request.POST中包含了username等键值对
        if login_form.is_valid():  # 判断login_form是否有效，并进行forms.py中的clean方法
            user = login_form.clean_data['user']
            auth.login(request, user)  # 登录
            return redirect(request.GET.get('from', reverse('home'))) 
    else:
        login_form = LoginForm(
    context = {}
    context['login_form'] = login_form # 如果错误，此时login_form携带了上面增加的错误信息
    return render(request, 'login.html', context)
```

此时在执行`.is_valid()`时，运行的是forms.py文件中LoginForm类进行了多步操作，其中一步是中LoginForm类中的clean方法（或是clean_xxxx)

> 参考：https://blog.csdn.net/weixin_43819222/article/details/94176820

```python
class LoginForm(forms.Form):
    username = forms.CharField(label='用户名', required=True, 
                               widget=forms.TextInput(attrs={'class':'form-control', 'placeholder':'请输入用户名'})) 
    password = forms.CharField(label='密码', widget=forms.PasswordInput(attrs={'class':'form-control', 'placeholder':'请输入密码'})) 
    def clean(self):
        username = self.cleaned_data['username']
        password = self.cleaned_data['password']
        user = auth.authenticate(username=username, password=password) 
        if user is None:   
            raise forms.ValidationError('用户名或密码不正确')
        else:
            self.cleaned_data['user'] = user
        return self.cleaned_data
```



# 25. 富文本编辑和ajax提交评论

## 1、django-ckeditor富文本表单

![](https://gitee.com/gitten/PicBed/raw/master/20200803220152.png)



### 1.使用form表单修改评论功能

1.在comment文件夹下新建forms.py文件

```python
from django import forms
from django.contrib import auth
from django.contrib.auth.models import User

class CommentForm(forms.Form):
    content_type = forms.CharField(widget=forms.HiddenInput) # HiddenInput在前端隐藏显示
    object_id = forms.IntegerField(widget=forms.HiddenInput)
    text = forms.CharField(widget=forms.Textarea) 
```

2.修改blog/views.py中的blog_detail()方法

传递`context['comment_form']`值，并通过initial进行初始化值

```python
from comment.forms import CommentForm

def blog_detail(request,blog_pk):
    ...
    context['comment_form'] = CommentForm(initial={'content_type':blog_content_type.model, 'object_id':blog_pk}) 
    # 对forms表单中的类进行初始化定义值，initial对应的是一个list
    response = render(request, 'blog/blog_detail.html',context)  # 响应
    response.set_cookie(read_cookie_key, 'true')  # 阅读cookie标记

    return response

```

3.修改模板页面

使用`  {{ comment_form }}`使用传递过来的 comment_form

```django
<form action="{% url 'update_comment' %}" method="POST" style="overflow:hidden;">
  <label>{{ user.username }}，欢迎评论~</label>
  {% csrf_token %}
  {{ comment_form }}
  <input type="submit" value="评论" class="btn btn-primary" style="float:right">
</form>
```



### 2.修改验证comment的方法

因为blog有自己的编辑页面，所以这个页面会设计两个POST，所以建议不将校验过程写在views.py中

建议放在forms.py中

#### （1）在comment/forms.py中新建一个CommentForm的方法clean()

```python
class CommentForm(forms.Form):
    content_type = forms.CharField(widget=forms.HiddenInput) # HiddenInput在前端隐藏显示
    object_id = forms.IntegerField(widget=forms.HiddenInput)
    text = forms.CharField(widget=forms.Textarea)

    # 继承forms.Form进行实例化，在这个类中隐藏一个初始化的方法
    def __init__(self, *args, **kwargs):  # *args表示任意类型的参数；**kwargs表示任意关键字的参数
        if 'user' in kwargs: # 如果'user'在kwargs中做以下操作
            self.user = kwargs.pop('user') # pop()表示将'user'的内容从kwargs中拿出来剔除，放入self.user中，防止在super初始化时有参数报错
        super(CommentForm, self).__init__(*args, **kwargs) # 继承初始化的方法

    def clean(self):
        # 判断用户是否登录
        if self.user.is_authenticated:
            self.cleaned_data['user'] = self.user
        else:
            raise forms.ValidationError('用户尚未登录')
        #评论对象验证
        content_type = self.cleaned_data['content_type']
        object_id = self.cleaned_data['object_id']
        try:
            model_class = ContentType.objects.get(model=content_type).model_class()
            # 使用ContentType进行处理，根据'content_type'得到blog等对象类型,ContentType.objects.get获得一个外键关联的具体的blog对象
            # 使用model_class方法，可以得到具体的模型的class, 也就是得到Blog；使用model_class方法，可以根据一个具体的object对象，返回这个对象所属的class类
            model_obj = model_class.objects.get(pk=object_id)
            self.cleaned_data['content_object'] = model_obj
        except ObjectDoesNotExist:
            raise forms.ValidationError('评论不存在')
        return self.cleaned_data
```

#### （2）修改comment/views.py中的update_comment函数

使用python中的关键词传参数，传递user

并使用.is_valid()对POST中的内容进行验证

通过验证后将POST中的内容作为Comment类实例化保存，完成评论

未通过验证则报错

```python
def update_comment(request):
    referer = request.META.get('HTTP_REFERER', reverse('home'))
    comment_form = CommentForm(request.POST, user=request.user) # 进行实例化；使用python中的关键词传参数，传递user
    if comment_form.is_valid(): # 如果POST中的数据有效的话，就进行保存
        comment = Comment()
        comment.user = comment_form.cleaned_data['user']
        comment.text = comment_form.cleaned_data['text']
        comment.content_object = comment_form.cleaned_data['content_object']
        comment.save()
        return redirect(referer)
    else:
        return render(request, 'error.html', {'message':comment_form.errors, 'redirect_to':referer})
```



### 3.修改富文本编辑框

在GitHub中搜索[django-ckeditor](https://github.com/django-ckeditor/django-ckeditor)

并寻找包含form的内容：

[Widget](https://github.com/django-ckeditor/django-ckeditor#id8)

Alternatively, you can use the included `CKEditorWidget` as the widget for a formfield. For example:

```
from django import forms
from django.contrib import admin
from ckeditor.widgets import CKEditorWidget

from post.models import Post

class PostAdminForm(forms.ModelForm):
    content = forms.CharField(widget=CKEditorWidget())
    class Meta:
        model = Post
        fields = '__all__'

class PostAdmin(admin.ModelAdmin):
    form = PostAdminForm

admin.site.register(Post, PostAdmin)
```

![](https://gitee.com/gitten/PicBed/raw/master/20200809171628.png)

#### 使用widget使用富文本编辑器

（1）修改forms.py中text的widget

```python
from ckeditor.widgets import CKEditorWidget

class CommentForm(forms.Form):
    ...
    text = forms.CharField(widget=CKEditorWidget())
    ...
```

（2）在模板页面中引入需要用的js库

```django
{% block header_extends %}
    <link rel="stylesheet" type="text/css" href="{% static 'blog/blog.css' %}">
    <script type="text/javascript" src="{% static "ckeditor/ckeditor-init.js" %}"></script>
    <script type="text/javascript" src="{% static "ckeditor/ckeditor/ckeditor.js" %}"></script>
{% endblock %}
```

#### 配置CKeditor的背景

![image-20200809174832128](/Users/gitten/Library/Application Support/typora-user-images/image-20200809174832128.png)

配置widget

```
text = forms.CharField(widget=CKEditorWidget(config_name='comment_ckeditor'))
```

修改SETTINGS.py的中的`CKEDITOR_CONFIGS`

```
CKEDITOR_CONFIGS = {
    'comment_ckeditor': {
        'toolbar': 'custom',
        'toolbar_custom': [
            ['Bold', 'Italic', 'Underline', 'Strike', 'Subscript', 'Superscript'],
            ["TextColor", "BGColor", 'RemoveFormat'],
            ['NumberedList', 'BulletedList'],
            ['Link', 'Unlink'],
            ["Smiley", "SpecialChar", 'Blockquote'],
        ],
        'width': 'auto',
        'height': '180',
        'tabSpaces': 4, # tab键变为四个空格
        'removePlugins': 'elementspath',
        'resize_enabled': False,
    }
}
```

#### 去除页面上的text英文

```django 
<form action="{% url 'update_comment' %}" method="POST" style="overflow:hidden;">
  <label>{{ user.username }}，欢迎评论~</label>
  {% csrf_token %}
  {% for field in comment_form %}
  	{{ field }}
  {% endfor %} 
  <input type="submit" value="评论" class="btn btn-primary" style="float:right">
</form>
```

#### 使评论框占页面宽度100%

blog/static/blog.css

```css
div.django-ckeditor-widget {
    width:100%;
}
```

## 2、ajax提交

需要评论后页面不刷新，使用ajax异步请求

正常提交会刷新页面，可以ajax提交数据

ajax提交是一种不刷新页面的异步提交方式

### 1.修改模板页面

在模板页面最下面插入script代码，使用jQuery实现ajax提交

```django
{% block script_extends %}
    <script type="text/javascript">
        $("#comment_form").submit(function(){
            // 更新数据到textarea中
            CKEDITOR.instances['id_text'].updateElement();
            // 异步提交
            $.ajax({
                url: "{% url 'update_comment' %}",
                type: 'POST',
                data: $(this).serialize()  // $(this)表示使用当前方法中的对象，等同于$("#comment_form")；使用serialize()将这些对象序列化
                cache: false, // 将缓存关闭
                success: function(data){  // 执行成功后会执行法法
                    console.log(data);  // console.log() 方法用于在控制台输出信息。
                    if(data['status']=="SUCCESS"){
                        // 插入数据
                        var comment_html = '<div>' + data['username'] + 
                                                     ' (' + data['comment_time'] + '): ' + 
                                                     data['text'] + '</div>';
                        $("#comment_list").prepend('comment_html'); // 在comment_list的开头插入comment_html
                    }else{
                    }
                },
                error: function(xhr){
                    console.log(xhr);
                }
            })
            return false
        });
    </script>
{% endblock %}
```

### 2.修改update_comment路由函数

在form提交后，以JSON格式返回数据，用于更改页面

```python
def update_comment(request):
    referer = request.META.get('HTTP_REFERER', reverse('home'))
    comment_form = CommentForm(request.POST, user=request.user) # 进行实例化；使用python中的关键词传参数，传递user
    data = {}
    if comment_form.is_valid(): # 如果POST中的数据有效的话，就进行保存
        comment = Comment()
        comment.user = comment_form.cleaned_data['user']
        comment.text = comment_form.cleaned_data['text']
        comment.content_object = comment_form.cleaned_data['content_object']
        comment.save()

        # 返回数据
        data['status'] = 'SUCCESS '
        data['username'] = comment.user.username
        data['comment_time'] = comment.comment_time.strftime('%Y-%m-%d %H:%m:%S')
        data['text'] = comment.text
    else:
        data['status'] = 'SUCCESS '
        #return render(request, 'error.html', {'message':comment_form.errors, 'redirect_to':referer})
    return JsonResponse(data)
```

### 3.ERROR时的处理方法

在模板页面增加显示错误信息的<span>

```django
<span id="comment_error" class="text-danger pull-left"></span>
```

然后用js获取这个<span>的id，然后设置错误信息

```javascript
if(data['status']=="SUCCESS"){
  // 插入数据
  var comment_html = '<div>' + data['username'] + ' (' + data['comment_time'] + '): ' + data['text'] + '</div>';
  $("#comment_list").prepend('comment_html'); // 在comment_list的开头插入comment_html
  // 评论提交后自动清空评论框内的文字
  CKEDITOR.instances['id_text'].setData('') 
}else{
  // 显示错误信息
  $("#comment_error").text(data['message'])
}
```

修改update_comment()中的错误返回

```python
def update_comment(request):
    ...
    if comment_form.is_valid(): # 如果POST中的数据有效的话，就进行保存
    		...
    else:
        data['status'] = 'ERROR'
        # 取错误信息中的values，并将其转为list，并取第一个
        data['message'] = list(comment_form.errors.values())[0][0]
    return JsonResponse(data)
```

评论为空时，自定义报错内容，修改comment/forms.py中的CommentForm类中text属性的widget参数，为error_messages添加一个字典

```python
class CommentForm(forms.Form):
    ...
    text = forms.CharField(widget=CKEditorWidget(config_name='comment_ckeditor'),
                           error_messages={'required':'评论内容不能为空'})
```

为减轻服务器的负担，在前端对评论是否为空进行判断

```js
// 判断是否为空
$("#comment_error").text('');
if(CKEDITOR.instances['id_text'].document.getBody().getText().trim()==''){
    // 显示错误信息
    $("#comment_error").text('评论内容不能为空');
}
```

## 3、更正

### 几个小细节

1. 时间格式修饰器前面写错了

   `({{ comment.comment_time|date:"Y-m-d H:n:s" }})`  -->  `({{ comment.comment_time|date:"Y-m-d H:i:s" }})`

2. 富文本内容的html标签未在下方comment_list中转义

   `{{ comment.text|safe }} `  使评论内容中的html内容转义

3. 在settings.py中更改时区

4. 提交评论后自动清空评论框内的文字

   ```django
   CKEDITOR.instances['id_text'].setData('') // 评论提交后自动清空评论框内的文字
   ```



# 26.







